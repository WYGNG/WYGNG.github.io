<!DOCTYPE HTML>
<html lang="zh_CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="高级图像处理基础实验与图像处理基础理论知识, 鱼缸屋">
    <meta name="description" content="实验1：图像灰度变换实验一内容1、利用OpenCV读取图像具体内容：用OpenCV打开图像，并在窗口中显示。2、灰度图像二值化处理具体内容：设置并调整阈值对图像进行二值化处理。3、灰度图像的对数变换具体内容：设置并调整r值对图像进行对数变换">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>高级图像处理基础实验与图像处理基础理论知识 | 鱼缸屋</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/css/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
</head>


<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="container">
            <div class="nav-wrapper">
                <div class="brand-logo">
                    <a href="/" class="waves-effect waves-light">
                        
                        <img src="/medias/logo.png" class="logo-img hide-on-small-only">
                        
                        <span class="logo-span">鱼缸屋</span>
                    </a>
                </div>
                

<a href="#" data-activates="mobile-nav" class="button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li>
        <a id="toggleSearch" class="waves-effect waves-light">
            <i id="searchIcon" class="mdi-action-search" title="Search"></i>
        </a>
    </li>

</ul>

<div class="side-nav" id="mobile-nav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">鱼缸屋</div>
        <div class="logo-desc">
            
            海纳百川，有容乃大，壁立千仞，无欲则刚
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/WYGNG" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>来github一起玩吧！
            </a>
        </li>
        
    </ul>

    <div class="social-link">
    <a href="https://github.com/wygny" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:ygwu@mail.ustc.edu.cn" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=321699849" class="tooltipped" data-tooltip="QQ联系我: 321699849" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>



    <a href="https://www.baidu.com" class="tooltipped" target="_blank" data-tooltip="访问百度" data-position="top" data-delay="50">
        <i class="fa fa-paw"></i>
</a>



    <a href="https://www.google.com" class="tooltipped" target="_blank" data-tooltip="访问谷歌" data-position="top" data-delay="50">
        <i class="fa fa-google"></i>
</a>



    <a href="https://www.bilibili.com" class="tooltipped" target="_blank" data-tooltip="访问哔哩哔哩" data-position="top" data-delay="50">
        <i class="fa fa-bullseye"></i>
</a>



    <a href="https://blog.csdn.net/zgcr654321" class="tooltipped" target="_blank" data-tooltip="访问我的CSDN博客" data-position="top" data-delay="50">
        <i class="fa fa-copyright"></i>
</a>






</div>
</div>

            </div>
        </div>

        
        <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/WYGNG" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="来github一起玩吧！" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>
</header>





<div class="bg-cover post-cover" style="background-image: url('/medias/featureimages/22.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        高级图像处理基础实验与图像处理基础理论知识
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }
</style>
<div class="row">
    <div class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/图像处理/" target="_blank">
                                <span class="chip bg-color">图像处理</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/图像处理/" class="post-category" target="_blank">
                                图像处理
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2019-05-04
                </div>

                
                    
                    <div class="info-break-policy">
                        <i class="fa fa-file-word-o fa-fw"></i>Word Count:&nbsp;&nbsp;
                        24.9k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="fa fa-clock-o fa-fw"></i>Read Times:&nbsp;&nbsp;
                        112 Min
                    </div>
                    
                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="fa fa-eye fa-fw"></i>Read Count:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="实验1：图像灰度变换"><a href="#实验1：图像灰度变换" class="headerlink" title="实验1：图像灰度变换"></a>实验1：图像灰度变换</h1><h2 id="实验一内容"><a href="#实验一内容" class="headerlink" title="实验一内容"></a>实验一内容</h2><p>1、利用OpenCV读取图像<br>具体内容：用OpenCV打开图像，并在窗口中显示。<br>2、灰度图像二值化处理<br>具体内容：设置并调整阈值对图像进行二值化处理。<br>3、灰度图像的对数变换<br>具体内容：设置并调整r值对图像进行对数变换。<br>4、灰度图像的伽马变换<br>具体内容：设置并调整γ值对图像进行伽马变换。<br>5、彩色图像的补色变换<br>具体内容：对彩色图像进行补色变换。</p>
<h2 id="实验一理论知识"><a href="#实验一理论知识" class="headerlink" title="实验一理论知识"></a>实验一理论知识</h2><p><strong>灰度值计算公式:</strong><br>$$<br>Gray=0.299R+0.587G+0.114B<br>$$<br>对于灰度值，0是黑色，255是白色。<br><strong>对数变换公式:</strong><br>$$<br>s=\frac{c \log(1+vr)}{log(v+1)}<br>$$<br>r的灰度值归一化为[0,1]之间的值。对数变换可以拉伸范围较窄的低灰度值，同时压缩范围较宽的高灰度值。可以用来扩展图像中的暗像素值，同时压缩亮像素值。常用值：c = 1.0, v = 5.0。<br><strong>伽马变换公式:</strong><br>$$<br>s=c r^{\gamma}<br>$$<br>当γ&gt;1时将较窄范围的低灰度值映射为较宽范围的灰度值，同时将较宽范围的高灰度值映射为较窄范围的灰度值；当γ&lt;1时，情况相反，与反对数变换类似。<br>当γ&lt;1时，γ的值越小，对图像低灰度值的扩展越明显；当γ&gt;1时，γ的值越大，对图像高灰度值部分的扩展越明显。这样就能够显示更多的图像的低灰度或者高灰度细节。<br><strong>反色、补色变换公式:</strong><br>$$<br>C_{New} = 255 - C_{Old}<br>$$<br>$$<br>C_{New} = Max(R,G,B)+Min(R,G,B)-C_{Old}<br>$$<br>一种颜色反色或补色后，颜色的色相值与反相前相差180度，这是反色和补色的共同点。不同点是，反色除了要改变色相以外，纯度和明度也做出了相应的改变，而补色不改变纯度和明度。例如，黑色的反色是白色，黑色的补色还是黑色。</p>
<h2 id="VS2017中配置opencv3-4-1环境"><a href="#VS2017中配置opencv3-4-1环境" class="headerlink" title="VS2017中配置opencv3.4.1环境"></a>VS2017中配置opencv3.4.1环境</h2><p>从这里:<a href="https://opencv.org/releases/page/2/" target="_blank" rel="noopener">https://opencv.org/releases/page/2/</a> 下载opencv3.4.1，选择windows版，如果下载时速度太慢请打开vpn。<br>下载完成后得到一个自解压压缩包，解压，将得到的opencv341文件夹放在如C:\Program Files位置，并在环境变量中添加C:\Program Files\opencv341\build\x64\vc15\bin。<br>新建一个VS的C++ Win32 Console Application工程，点击项目-&gt;属性-&gt;VC++目录，平台选择x64，配置选择活动（debug）。<br>包含目录项添加下面的路径:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\opencv341\build\include</span><br><span class="line">C:\Program Files\opencv341\build\include\opencv</span><br><span class="line">C:\Program Files\opencv341\build\include\opencv2</span><br></pre></td></tr></table></figure>

<p>库目录项添加下面的路径:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\opencv341\build\x64\vc15\lib</span><br></pre></td></tr></table></figure>

<p>点击链接器-&gt;输入-&gt;附加依赖项，添加下面的路径:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opencv_world341d.lib //d表示debug版本</span><br></pre></td></tr></table></figure>

<p>这样我们的opencv环境就配置好了。我们还可以把这个配置保存下来，在菜单栏中选择：视图-&gt; 其他窗口-&gt;属性管理器，找到其中的Debug|x64项，点击添加新属性表，命名为opencv341.props，然后将这个属性表中属性按上面修改一遍，保存下来，这样在新建其他项目时只需要在这个属性管理器中导入opencv341.props属性表即可。</p>
<h2 id="实验一代码"><a href="#实验一代码" class="headerlink" title="实验一代码"></a>实验一代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt; //包含imread, imshow等</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt; //包含cvtColor等</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取、显示、保存图片</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadAndSaveImage</span><span class="params">(<span class="built_in">string</span> load_path, <span class="built_in">string</span> save_path)</span> </span>&#123;</span><br><span class="line">	Mat pScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">1</span>);</span><br><span class="line">	imshow(<span class="string">"picture"</span>, pScr);</span><br><span class="line">	imwrite(save_path, pScr);</span><br><span class="line">	<span class="comment">// 等待按下某键(ASCII码值),若为0则按下任意键后程序退出,若写3000就是3秒后程序自动退出</span></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	destroyAllWindows();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图像二值化处理,使用整幅图像的灰度平均值作为二值化的阈值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binaryImage</span><span class="params">(<span class="built_in">string</span> load_path, <span class="built_in">string</span> save_path_gray, <span class="built_in">string</span> save_path_gray_binary)</span> </span>&#123;</span><br><span class="line">	Mat pScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 图像行列数</span></span><br><span class="line">	<span class="keyword">int</span> row = pScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = pScr.cols;</span><br><span class="line">	<span class="function">Mat <span class="title">graypScr</span><span class="params">(row, col, CV_8UC1)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">			<span class="comment">// 0、1、2位置分别为b、g、r通道</span></span><br><span class="line">			graypScr.at&lt;uchar&gt;(i, j) = <span class="keyword">int</span>(<span class="number">0.2989</span>*<span class="keyword">int</span>(pScr.at&lt;Vec3b&gt;(i, j)[<span class="number">0</span>]) + <span class="number">0.5870</span>*<span class="keyword">int</span>(pScr.at&lt;Vec3b&gt;(i, j)[<span class="number">1</span>]) + <span class="number">0.1140</span>*<span class="keyword">int</span>(pScr.at&lt;Vec3b&gt;(i, j)[<span class="number">2</span>]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// imshow("gray_picture", graypScr);</span></span><br><span class="line">	<span class="comment">// waitKey(0);</span></span><br><span class="line">	<span class="comment">// destroyAllWindows();</span></span><br><span class="line">	imwrite(save_path_gray, graypScr);</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>, threshold = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 计算阈值为所有灰度值的平均值</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">			sum = sum + <span class="keyword">int</span>(graypScr.at&lt;uchar&gt;(i, j));</span><br><span class="line">	&#125;</span><br><span class="line">	threshold = <span class="keyword">int</span>(sum / (row*col));</span><br><span class="line">	<span class="comment">// 灰度图像二值化,大于等于阈值置为255,否则置为0</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">int</span>(graypScr.at&lt;uchar&gt;(i, j)) &gt;= threshold)</span><br><span class="line">				graypScr.at&lt;uchar&gt;(i, j) = <span class="number">255</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				graypScr.at&lt;uchar&gt;(i, j) = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// imshow("binary_gray_picture", graypScr);</span></span><br><span class="line">	<span class="comment">// waitKey(0);</span></span><br><span class="line">	<span class="comment">// destroyAllWindows();</span></span><br><span class="line">	imwrite(save_path_gray_binary, graypScr);;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 灰度图像的对数变换s = c * log(1+r*v)/log(v),更突出暗部细节</span></span><br><span class="line"><span class="comment">// 对数变换将源图像中范围较窄的低灰度值映射到范围较宽的灰度区间,同时将范围较宽的高灰度值区间映射为较窄的灰度区间</span></span><br><span class="line"><span class="comment">// 从而扩展了暗像素的值，压缩了高灰度的值，能够对图像中低灰度区域进行增强</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LogImage</span><span class="params">(<span class="built_in">string</span> load_path, <span class="built_in">string</span> save_path_gray_log)</span> </span>&#123;</span><br><span class="line">	Mat graypScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	graypScr = imread(load_path, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// imshow("picture", graypScr);</span></span><br><span class="line">	<span class="comment">// waitKey(0);</span></span><br><span class="line">	<span class="comment">// destroyAllWindows();</span></span><br><span class="line">	<span class="comment">// 图像行列数</span></span><br><span class="line">	<span class="keyword">int</span> row = graypScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = graypScr.cols;</span><br><span class="line">	<span class="keyword">double</span> c = <span class="number">1.0</span>, v = <span class="number">5.0</span>;</span><br><span class="line">	<span class="comment">// 灰度图像的对数变换</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">			<span class="keyword">double</span> r = graypScr.at&lt;uchar&gt;(i, j) / <span class="number">255.0</span>;</span><br><span class="line">			<span class="keyword">double</span> s = c * <span class="built_in">log</span>(<span class="number">1</span> + r * v) / <span class="built_in">log</span>(v + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">int</span> d = <span class="keyword">int</span>(s * <span class="number">255</span>);</span><br><span class="line">			<span class="keyword">if</span> (d &lt; <span class="number">0</span>)</span><br><span class="line">				d = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (d &gt; <span class="number">255</span>)</span><br><span class="line">				d = <span class="number">255</span>;</span><br><span class="line">			graypScr.at&lt;uchar&gt;(i, j) = d;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// imshow("gray_log_picture", graypScr);</span></span><br><span class="line">	<span class="comment">// waitKey(0);</span></span><br><span class="line">	<span class="comment">// destroyAllWindows();</span></span><br><span class="line">	imwrite(save_path_gray_log, graypScr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 灰度图像的伽马变换s = c * pow(r, gama)</span></span><br><span class="line"><span class="comment">// (255,255,255)是白色，灰度值最高</span></span><br><span class="line"><span class="comment">// γ &gt; 1时，会将低于某个灰度值K的灰度区域压缩到较小的灰度区间,而将高于K的灰度区域扩展到较大灰度区间。令L为灰度的最大值,k = 3 / 4L</span></span><br><span class="line"><span class="comment">// [0, 3 / 4L]的灰度区域映射到为[0, 1 / 8L]的输出,而将[3 / 4L, L]这部分高灰度区域映射到[1 / 8L, L]区间</span></span><br><span class="line"><span class="comment">// 这样变换的结果就是，低于k的灰度区域被压缩到更低灰度区间,而较亮的高灰度区域的灰度值被扩展到较大的灰度区间变的不那么亮,整体的效果就是图像的对比度增加,但是由于亮度区域被扩展,也就不那么亮了。</span></span><br><span class="line"><span class="comment">// γ &lt; 1时,会将灰度值较小的低灰度区域扩展到较宽的灰度区间,而将较宽的高灰度区域压缩到较小的灰度区间。这样低灰度区域扩展开来变亮,而宽的高灰度区域被压缩到较窄的区间,也变亮,故变换后的整体效果是变亮了。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gamaImage</span><span class="params">(<span class="built_in">string</span> load_path, <span class="built_in">string</span> save_path_gray_gamma)</span> </span>&#123;</span><br><span class="line">	Mat graypScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	graypScr = imread(load_path, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// 图像行列数</span></span><br><span class="line">	<span class="keyword">int</span> row = graypScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = graypScr.cols;</span><br><span class="line">	<span class="keyword">double</span> c = <span class="number">1.0</span>, gama = <span class="number">3.0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">			<span class="keyword">double</span> r = graypScr.at&lt;uchar&gt;(i, j) / <span class="number">255.0</span>;</span><br><span class="line">			<span class="keyword">double</span> s = c * <span class="built_in">pow</span>(r, gama);</span><br><span class="line">			<span class="keyword">int</span> d = <span class="keyword">int</span>(s * <span class="number">255</span>);</span><br><span class="line">			<span class="keyword">if</span> (d &lt; <span class="number">0</span>)</span><br><span class="line">				d = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (d &gt; <span class="number">255</span>)</span><br><span class="line">				d = <span class="number">255</span>;</span><br><span class="line">			graypScr.at&lt;uchar&gt;(i, j) = d;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// imshow("gray_gamma_picture", graypScr);</span></span><br><span class="line">	<span class="comment">// waitKey(0);</span></span><br><span class="line">	<span class="comment">// destroyAllWindows();</span></span><br><span class="line">	imwrite(save_path_gray_gamma, graypScr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 彩色图像的补色变换(反色差)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">imcomplementImage</span><span class="params">(<span class="built_in">string</span> load_path, <span class="built_in">string</span> save_path_color)</span> </span>&#123;</span><br><span class="line">	Mat pScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 图像行列数</span></span><br><span class="line">	<span class="keyword">int</span> row = pScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = pScr.cols;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">			pScr.at&lt;Vec3b&gt;(i, j)[<span class="number">0</span>] = <span class="number">255</span> - pScr.at&lt;Vec3b&gt;(i, j)[<span class="number">0</span>];</span><br><span class="line">			pScr.at&lt;Vec3b&gt;(i, j)[<span class="number">1</span>] = <span class="number">255</span> - pScr.at&lt;Vec3b&gt;(i, j)[<span class="number">1</span>];</span><br><span class="line">			pScr.at&lt;Vec3b&gt;(i, j)[<span class="number">2</span>] = <span class="number">255</span> - pScr.at&lt;Vec3b&gt;(i, j)[<span class="number">2</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// imshow("color_picture", graypScr);</span></span><br><span class="line">	<span class="comment">// waitKey(0);</span></span><br><span class="line">	<span class="comment">// destroyAllWindows();</span></span><br><span class="line">	imwrite(save_path_color, pScr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> load_path = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/1/save/lenna.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/1/save/lenna_save.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_gray = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/1/save/lenna_gray.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_gray_binary = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/1/save/lenna_binary_gray.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_gray_log = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/1/save/lenna_gray_log.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_gray_gamma = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/1/save/lenna_gray_gamma.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_color = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/1/save/lenna_color.bmp"</span>;</span><br><span class="line">	loadAndSaveImage(load_path, save_path);</span><br><span class="line">	binaryImage(load_path, save_path_gray, save_path_gray_binary);</span><br><span class="line">	LogImage(load_path, save_path_gray_log);</span><br><span class="line">	gamaImage(load_path, save_path_gray_gamma);</span><br><span class="line">	imcomplementImage(load_path, save_path_color);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实验二：直方图均衡"><a href="#实验二：直方图均衡" class="headerlink" title="实验二：直方图均衡"></a>实验二：直方图均衡</h1><h2 id="实验二内容"><a href="#实验二内容" class="headerlink" title="实验二内容"></a>实验二内容</h2><p>1、计算灰度图像的归一化直方图<br>具体内容：利用OpenCV对图像像素进行操作，计算归一化直方图，并在窗口中以图形的方式显示出来。<br>2、灰度图像直方图均衡处理<br>具体内容：通过计算归一化直方图，设计算法实现直方图均衡化处理。<br>3、彩色图像直方图均衡处理<br>具体内容： 在灰度图像直方图均衡处理的基础上实现彩色直方图均衡处理。</p>
<h2 id="实验二理论知识"><a href="#实验二理论知识" class="headerlink" title="实验二理论知识"></a>实验二理论知识</h2><p><strong>归一化直方图公式:</strong><br>先计算每个灰度值的像素个数<br>$$<br>\mathrm{h}\left(r_{k}\right)=n_{k}<br>$$<br>然后都除以全图像素个数，得到灰度值分布概率函数P（rk），我们就可以得到归一化的灰度直方图。<br>$$<br>\mathrm{P}\left(r_{k}\right)=\frac{n_{k} }{n}<br>$$<br><strong>直方图均衡化公式:</strong><br>用上面得到的灰度值分布概率函数P（rk）计算灰度值累积分布函数Sk:<br>$$<br>S_{k}=\sum_{i=0}^{k-1} P\left(r_{k}\right)=\sum_{i=0}^{k-1} \frac{n_{k}}{n}<br>$$<br>映射后的灰度值为:<br>$$<br>G_{k}=(L-1)S_{k}<br>$$<br>注意L-1=255，累积分布函数Sk和输入图像的灰度级相乘，不一定得到一个整数，但是输出的灰度级要求整数，于是我们这里四舍五入取整数灰度级。最后我们只要遍历所有像素点将原灰度值换成映射后的灰度值即可。对于彩色图像的直方图均衡，在R、G、B三个通道上分别做直方图均衡即可。</p>
<h2 id="实验二代码"><a href="#实验二代码" class="headerlink" title="实验二代码"></a>实验二代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt; //包含imread, imshow等</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt; //包含cvtColor等</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">grayImageGetHistImage</span><span class="params">(<span class="built_in">string</span> load_path, <span class="built_in">string</span> save_path_hist_image)</span> </span>&#123;</span><br><span class="line">	Mat graypScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	graypScr = imread(load_path, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// imshow("gray_picture", graypScr);</span></span><br><span class="line">	<span class="comment">// waitKey(0);</span></span><br><span class="line">	<span class="comment">// destroyAllWindows();</span></span><br><span class="line">	<span class="keyword">int</span> row = graypScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = graypScr.cols;</span><br><span class="line">	<span class="comment">// 用一个数组记录0-255的灰度值的数量,数组下标就是灰度值</span></span><br><span class="line">	<span class="keyword">int</span> grayNum[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">// 遍历所有像素点,记录每一个灰度值的数量</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">			grayNum[<span class="keyword">int</span>(graypScr.at&lt;uchar&gt;(i, j))] = grayNum[<span class="keyword">int</span>(graypScr.at&lt;uchar&gt;(i, j))] + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 找出灰度值数量的最大值</span></span><br><span class="line">	<span class="keyword">double</span> maxValue = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (grayNum[i] &gt; maxValue)</span><br><span class="line">			maxValue = grayNum[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 划分成256块</span></span><br><span class="line">	<span class="keyword">int</span> bin_num = <span class="number">256</span>;</span><br><span class="line">	<span class="comment">// 生成白色画布(255)</span></span><br><span class="line">	<span class="function">Mat <span class="title">histImg</span><span class="params">(bin_num, bin_num, CV_8U, Scalar(<span class="number">255</span>))</span></span>;</span><br><span class="line">	<span class="comment">// 每个块是一条垂线	</span></span><br><span class="line">	<span class="keyword">int</span> hpt = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">0.9</span>*bin_num);</span><br><span class="line">	<span class="comment">// 对每一个块,用其灰度值数量乘以hpt再除以灰度值数量最大值，这样就转化成程度</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bin_num; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> intensity = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(grayNum[i] * hpt / maxValue);</span><br><span class="line">		<span class="comment">//直方图底部点与直方图顶部点之间绘制一条线		</span></span><br><span class="line">		line(histImg, Point(i, bin_num), Point(i, bin_num - intensity), Scalar::all(<span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// imshow("hist_image", histImg);</span></span><br><span class="line">	<span class="comment">// waitKey(0);</span></span><br><span class="line">	<span class="comment">// destroyAllWindows();</span></span><br><span class="line">	imwrite(save_path_hist_image, histImg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 灰度直方图均衡化步骤:</span></span><br><span class="line"><span class="comment">// 统计原始图像各灰度值的数量;图像中灰度值为i的像素的出现概率是:px(i)=p(x=i)=ni/n,n是图像中所有的像素数,px(i)实际上是灰度值为i的图像的直方图,归一化到[0, 1];</span></span><br><span class="line"><span class="comment">// px的累积分布函数,是图像的累计归一化直方图:cdfx(i)=j从0到i求和px(j)</span></span><br><span class="line"><span class="comment">// 直方图均衡化计算公式,cdfmin为累积分布函数最小值,M和N分别代表了图像的长宽像素个数,L是灰度值的个数(如256),v为原始图像中为v的像素值</span></span><br><span class="line"><span class="comment">// h(v)=round((cdf(v)-cdfmin)*(L-1)/(M*N-cdfmin))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">grayImageHistEqualization</span><span class="params">(<span class="built_in">string</span> load_path, <span class="built_in">string</span> save_path_gray, <span class="built_in">string</span> save_path_gray_image_equalization, <span class="built_in">string</span> save_path_hist_image_equalization)</span> </span>&#123;</span><br><span class="line">	Mat graypScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	graypScr = imread(load_path, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// imshow("gray_picture", graypScr);</span></span><br><span class="line">	<span class="comment">// waitKey(0);</span></span><br><span class="line">	<span class="comment">// destroyAllWindows();</span></span><br><span class="line">	imwrite(save_path_gray, graypScr);</span><br><span class="line">	<span class="keyword">int</span> row = graypScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = graypScr.cols;</span><br><span class="line">	<span class="comment">// 用一个数组记录0-255的灰度值的数量,数组下标就是灰度值</span></span><br><span class="line">	<span class="keyword">double</span> grayProbability[<span class="number">256</span>] = &#123; <span class="number">0.0</span> &#125;;</span><br><span class="line">	<span class="comment">// 遍历所有像素点,记录每一个灰度值的数量</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">			grayProbability[<span class="keyword">int</span>(graypScr.at&lt;uchar&gt;(i, j))] = grayProbability[<span class="keyword">int</span>(graypScr.at&lt;uchar&gt;(i, j))] + <span class="number">1.0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 求图像中灰度值为i的像素出现概率</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">		grayProbability[i] = grayProbability[i] / (row*col*<span class="number">1.0</span>);</span><br><span class="line">	<span class="keyword">double</span> cdf[<span class="number">256</span>] = &#123; <span class="number">0.0</span> &#125;;</span><br><span class="line">	<span class="comment">// 求px的累积分布函数,每个i的累积分布函数是灰度值从0到i的像素出现概率的累加之和</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">			cdf[i] += grayProbability[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> L = <span class="number">255</span>;</span><br><span class="line">	<span class="comment">// 该数组记录了均衡后原始灰度值(数组下标)对应的均衡后的灰度值,计算式为D[i]=L*cdf[i]</span></span><br><span class="line">	<span class="keyword">int</span> D[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">		D[i] = <span class="keyword">int</span>(L*cdf[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 对灰度图像做均衡化处理,每个像素点原有灰度值替换为均衡后的灰度值</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">			<span class="keyword">int</span> grayValue = <span class="keyword">int</span>(graypScr.at&lt;uchar&gt;(i, j));</span><br><span class="line">			graypScr.at&lt;uchar&gt;(i, j) = D[grayValue];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// imshow("gray_equalization_picture", graypScr);</span></span><br><span class="line">	<span class="comment">// waitKey(0);</span></span><br><span class="line">	<span class="comment">// destroyAllWindows();</span></span><br><span class="line">	imwrite(save_path_gray_image_equalization, graypScr);</span><br><span class="line">	grayImageGetHistImage(save_path_gray_image_equalization, save_path_hist_image_equalization);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">colorImageHistEqualization</span><span class="params">(<span class="built_in">string</span> load_path, <span class="built_in">string</span> save_path_color_image_equalization)</span> </span>&#123;</span><br><span class="line">	Mat pScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">// imshow("gray_picture", graypScr);</span></span><br><span class="line">	<span class="comment">// waitKey(0);</span></span><br><span class="line">	<span class="comment">// destroyAllWindows();</span></span><br><span class="line">	<span class="keyword">int</span> row = pScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = pScr.cols;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">		<span class="function">Mat <span class="title">singleChannel</span><span class="params">(row, col, CV_8UC1)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">				<span class="comment">// 0、1、2位置分别为b、g、r通道,每次提取一个通道的值存在一个单通道的Mat矩阵中,作为灰度图像处理</span></span><br><span class="line">				singleChannel.at&lt;uchar&gt;(i, j) = <span class="keyword">int</span>(pScr.at&lt;Vec3b&gt;(i, j)[k]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 用一个数组记录0-255的灰度值的数量,数组下标就是灰度值</span></span><br><span class="line">		<span class="keyword">double</span> grayProbability[<span class="number">256</span>] = &#123; <span class="number">0.0</span> &#125;;</span><br><span class="line">		<span class="comment">// 遍历所有像素点,记录每一个灰度值的数量</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">				grayProbability[<span class="keyword">int</span>(singleChannel.at&lt;uchar&gt;(i, j))] = grayProbability[<span class="keyword">int</span>(singleChannel.at&lt;uchar&gt;(i, j))] + <span class="number">1.0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 求图像中灰度值为i的像素出现概率</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">			grayProbability[i] = grayProbability[i] / (row*col*<span class="number">1.0</span>);</span><br><span class="line">		<span class="keyword">double</span> cdf[<span class="number">256</span>] = &#123; <span class="number">0.0</span> &#125;;</span><br><span class="line">		<span class="comment">// 求px的累积分布函数,每个i的累积分布函数是灰度值从0到i的像素出现概率的累加之和</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">				cdf[i] += grayProbability[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> L = <span class="number">255</span>;</span><br><span class="line">		<span class="comment">// 该数组记录了均衡后原始灰度值(数组下标)对应的均衡后的灰度值,计算式为D[i]=L*cdf[i]</span></span><br><span class="line">		<span class="keyword">int</span> D[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">			D[i] = <span class="keyword">int</span>(L*cdf[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 对灰度图像做均衡化处理,每个像素点原有灰度值替换为均衡后的灰度值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">				<span class="keyword">int</span> grayValue = <span class="keyword">int</span>(singleChannel.at&lt;uchar&gt;(i, j));</span><br><span class="line">				singleChannel.at&lt;uchar&gt;(i, j) = D[grayValue];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// imshow("single_channel_equalization_picture", singleChannel);</span></span><br><span class="line">		<span class="comment">// waitKey(0);</span></span><br><span class="line">		<span class="comment">// destroyAllWindows();</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">				<span class="comment">// 将均衡化后的灰度值分别写回b、g、r通道</span></span><br><span class="line">				pScr.at&lt;Vec3b&gt;(i, j)[k] = <span class="keyword">int</span>(singleChannel.at&lt;uchar&gt;(i, j));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// imshow("color_image_equalization_picture", pScr);</span></span><br><span class="line">	<span class="comment">// waitKey(0);</span></span><br><span class="line">	<span class="comment">// destroyAllWindows();</span></span><br><span class="line">	imwrite(save_path_color_image_equalization, pScr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> load_path = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/2/save/lenna.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_hist_image = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/2/save/lenna_hist_image.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_gray = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/2/save/lenna_gray.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_gray_image_equalization = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/2/save/lenna_gray_image_equalization.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_hist_image_equalization = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/2/save/lenna_hist_image_equalization.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_color_image_equalization = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/2/save/lenna_color_image_equalization.bmp"</span>;</span><br><span class="line">	grayImageGetHistImage(load_path, save_path_hist_image);</span><br><span class="line">	grayImageHistEqualization(load_path, save_path_gray, save_path_gray_image_equalization, save_path_hist_image_equalization);</span><br><span class="line">	colorImageHistEqualization(load_path, save_path_color_image_equalization);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实验三：空域滤波"><a href="#实验三：空域滤波" class="headerlink" title="实验三：空域滤波"></a>实验三：空域滤波</h1><h2 id="实验三内容"><a href="#实验三内容" class="headerlink" title="实验三内容"></a>实验三内容</h2><p>1、利用均值模板平滑灰度图像<br>具体内容：利用OpenCV对图像像素进行操作，分别利用3x3、5x5和9x9尺寸的均值模板平滑灰度图像。<br>2、利用高斯模板平滑灰度图像<br>具体内容：利用OpenCV对图像像素进行操作，分别利用3x3、5x5和9x9尺寸的高斯模板平滑灰度图像。<br>3、利用Laplacian、Robert、Sobel模板锐化灰度图像<br>具体内容：利用OpenCV对图像像素进行操作，分别利用Laplacian、Robert、Sobel模板锐化灰度图像。<br>4、利用高提升滤波算法增强灰度图像<br>具体内容：利用OpenCV对图像像素进行操作，设计高提升滤波算法增强图像。<br>5、利用均值模板平滑彩色图像<br>具体内容：利用OpenCV分别对图像像素的RGB三个通道进行操作，利用3x3、5x5和9x9尺寸的均值模板平滑彩色图像。<br>6、利用高斯模板平滑彩色图像<br>具体内容：利用OpenCV分别对图像像素的RGB三个通道进行操作，分别利用3x3、5x5和9x9尺寸的高斯模板平滑彩色图像。<br>7、利用Laplacian、Robert、Sobel模板锐化灰度图像<br>具体内容：利用OpenCV分别对图像像素的RGB三个通道进行操作，分别利用Laplacian、Robert、Sobel模板锐化彩色图像。</p>
<h2 id="实验三理论知识"><a href="#实验三理论知识" class="headerlink" title="实验三理论知识"></a>实验三理论知识</h2><p><strong>算数平均值滤波公式:</strong><br>$$<br>f(x, y)=\frac{1}{m n} \sum_{(x, y) \in S_{x y}} g(s, t)<br>$$<br>Sxy表示中心点在（x,y）处，大小为m×n的滤波器窗口。g（s,t）表示原始图像灰度值，f（x,y）表示均值滤波后得到的图像灰度值。均值滤波就是把窗口内的像素点上灰度值全部按权重1相加求和，再除以像素点个数，得到的灰度值就是窗口正中心像素点的灰度值。对于彩色图像，对其三个通道分别执行均值滤波即可。<br><strong>高斯滤波公式:</strong><br>先计算mxn大小的窗口中每个像素点的权重:<br>$$<br>h(x, y)=e^{-\frac{(x-x_{0})^{2}+(y-y_{0})^{2}}{2 \sigma^{2}}}<br>$$<br>其中（x0，y0）是窗口正中心的像素点坐标。<br>然后我们要将所有权重归一化，即上面的h（x，y）都乘以下面的系数:<br>$$<br>\frac{1}{\sum_{(i, j) \in w} w_{i, j}}<br>$$<br>最后将窗口中每个像素点灰度值乘以对应的权重并求和，得到的灰度值就是窗口正中心像素点的灰度值。对于彩色图像，对其三个通道分别执行高斯滤波即可。<br><strong>Laplacian算子:</strong><br>差分就是离散函数连续两项之差。<br>我们用图像灰度值梯度的变化来检测图像中物体的边缘，边缘处通常灰度值变化会很剧烈，相应的灰度值梯度会较大。但是在图像上各个像素点是离散点，因此我们用对x,y两个方向的二阶导数的差分来近似表示梯度。这就是Laplacian算子。<br>一维一阶差分公式:<br>$$<br>\frac{\partial f}{\partial x}=f(x+1)-f(x)<br>$$<br>一维二阶差分公式:<br>$$<br>\frac{\partial^{2} f}{\partial x^{2}}=f(x+1)+f(x-1)-2 f(x)<br>$$<br>在一个二维函数f（x,y）中，x,y两个方向的二阶差分分别为:<br>$$<br>\frac{\partial^{2} f}{\partial x^{2}}=f(x+1, y)+f(x-1, y)-2 f(x, y)<br>$$<br>$$<br>\frac{\partial^{2} f}{\partial y^{2}}=f(x, y+1)+f(x, y-1)-2 f(x, y)<br>$$<br>Laplace算子就是将上面两个二阶差分的结果相加:<br>$$<br>\nabla^{2} f(x, y)=f(x+1, y)+f(x-1, y)+f(x, y+1)+f(x, y-1)-4 f(x, y)<br>$$<br>写成模板形式为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0    1    0</span><br><span class="line">1    -4   1</span><br><span class="line">0    1    0</span><br></pre></td></tr></table></figure>

<p>当然还有扩展的模板形式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1    1    1        0    -1    0        -1    -1    -1</span><br><span class="line">1    -8   1       -1     4   -1        -1    8     -1        </span><br><span class="line">1    1    1        0    -1    0        -1    -1    -1</span><br></pre></td></tr></table></figure>

<p>对于彩色图像，对其三个通道分别执行Laplacian算子即可。<br><strong>Robert算子:</strong><br>使用一个对角线之差的绝对值之和来近似代表梯度。<br>$$<br>M(x, y) \approx\left|z_{9}-z_{5}\right|+\left|z_{8}-z_{6}\right|<br>$$<br>模板形式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">z1    z2    z3</span><br><span class="line">z4    z5    z6        -1    0        0    -1</span><br><span class="line">z7    z8    z9         0    1        1    0</span><br></pre></td></tr></table></figure>

<p>对于彩色图像，对其三个通道分别执行Robert算子即可。<br><strong>Sobel算子:</strong><br>对Robert算子的改进。<br>$$<br>M(x, y) \approx\left|\left(z_{7}+2 z_{8}+z_{9}\right)-\left(z_{1}+2 z_{2}+z_{3}\right)\right|+\left|\left(z_{3}+2 z_{6}+z_{9}\right)-\left(z_{1}+2 z_{4}+z_{7}\right)\right|<br>$$<br>模板形式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-1    0    1        -1    -2    -1</span><br><span class="line">-2    0    2        0     0     0</span><br><span class="line">-1    0    1        1     2     1</span><br></pre></td></tr></table></figure>

<p>对于彩色图像，对其三个通道分别执行Sobel算子即可。<br><strong>Laplacian算子、Robert算子、Sobel算子都对噪声敏感，因此一般提取边缘前都需要先平滑。</strong><br><strong>高提升滤波公式:</strong><br>$$<br>g=f+km \quad \quad k \begin{cases}{k&gt;1高提升滤波} \\ {k=1非锐化掩蔽} \\ {0&lt;k&lt;1不强调非锐化模板的贡献}\end{cases}<br>$$<br>先平滑原图像f，得到s；从原图像f中减去模糊图像s，产生的差值图像称为m=f-s。系数k越大对细节增强越明显；平滑时减弱的边缘，锐化后增强的更加明显。</p>
<h2 id="实验三代码"><a href="#实验三代码" class="headerlink" title="实验三代码"></a>实验三代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt; //包含imread, imshow等</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt; //包含cvtColor等</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gray_image</span><span class="params">(<span class="built_in">string</span> load_path, <span class="built_in">string</span> save_path_gray_image)</span> </span>&#123;</span><br><span class="line">	Mat graypScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	graypScr = imread(load_path, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//imshow("gray_picture", graypScr);</span></span><br><span class="line">	<span class="comment">//waitKey(0);</span></span><br><span class="line">	<span class="comment">//destroyAllWindows();</span></span><br><span class="line">	imwrite(save_path_gray_image, graypScr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 均值滤波,既可以对灰度图像,也可以对彩色图像</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mean_filter</span><span class="params">(<span class="built_in">string</span> load_path, <span class="keyword">int</span> mean_filter_size, <span class="built_in">string</span> save_path_mean_filter)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 滤波窗口尺寸必须为奇数</span></span><br><span class="line">	Mat pScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> row = pScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = pScr.cols;</span><br><span class="line">	<span class="keyword">int</span> channel = pScr.channels();</span><br><span class="line">	<span class="comment">//imshow("picture", pScr);</span></span><br><span class="line">	<span class="comment">//waitKey(0);</span></span><br><span class="line">	<span class="comment">//destroyAllWindows();</span></span><br><span class="line">	<span class="comment">// 滤波窗口中心</span></span><br><span class="line">	<span class="keyword">int</span> pos = (mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">// 从图片矩阵左上角开始从左到右从上到下使用滤波窗口处理图片矩阵,每次提取filter_size*filter_size的数据进入滤波窗口,计算平均值,然后替代滤波窗口中心值</span></span><br><span class="line">	<span class="comment">// 图片按每个通道来处理</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; channel; k++) &#123;</span><br><span class="line">		<span class="comment">// 每个滤波窗口中心位置都计算滤波窗口内通道值的平均值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> m = pos; m &lt; row - pos; m++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> n = pos; n &lt; col - pos; n++) &#123;</span><br><span class="line">				<span class="keyword">int</span> centerpointValue = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = m - (mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>; i &lt;= m + (mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>; i++)</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = n - (mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>; j &lt;= n + (mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>; j++)</span><br><span class="line">						centerpointValue += <span class="keyword">int</span>(pScr.at&lt;Vec3b&gt;(i, j)[k]);</span><br><span class="line">				centerpointValue = <span class="keyword">int</span>(centerpointValue / (mean_filter_size*mean_filter_size));</span><br><span class="line">				pScr.at&lt;Vec3b&gt;(m, n)[k] = centerpointValue;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 对边界进行处理,边界上的像素值取最邻近行的滤波窗口中心位置像素值</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; channel; k++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = pos; j &lt; col - pos; j++)</span><br><span class="line">				pScr.at&lt;Vec3b&gt;(i, j)[k] = pScr.at&lt;Vec3b&gt;(pos, j)[k];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; channel; k++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = row - pos; i &lt; row; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = pos; j &lt; col - pos; j++)</span><br><span class="line">				pScr.at&lt;Vec3b&gt;(i, j)[k] = pScr.at&lt;Vec3b&gt;(row - pos - <span class="number">1</span>, j)[k];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; channel; k++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pos; j++)</span><br><span class="line">				pScr.at&lt;Vec3b&gt;(i, j)[k] = pScr.at&lt;Vec3b&gt;(i, pos)[k];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; channel; k++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = col - pos; j &lt; col; j++)</span><br><span class="line">				pScr.at&lt;Vec3b&gt;(i, j)[k] = pScr.at&lt;Vec3b&gt;(i, col - pos - <span class="number">1</span>)[k];</span><br><span class="line">	imwrite(save_path_mean_filter, pScr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维高斯滤波,既可以对灰度图像,也可以对彩色图像</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gaussian_filter</span><span class="params">(<span class="built_in">string</span> load_path, <span class="keyword">int</span> gaussian_filter_size, <span class="keyword">double</span> sigma, <span class="built_in">string</span> save_path_gaussian_filter)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> PI = <span class="number">3.1415926</span>;</span><br><span class="line">	<span class="comment">// 滤波窗口尺寸必须为奇数</span></span><br><span class="line">	Mat pScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> row = pScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = pScr.cols;</span><br><span class="line">	<span class="keyword">int</span> channel = pScr.channels();</span><br><span class="line">	<span class="comment">//imshow("picture", pScr);</span></span><br><span class="line">	<span class="comment">//waitKey(0);</span></span><br><span class="line">	<span class="comment">//destroyAllWindows();</span></span><br><span class="line">	<span class="comment">// 滤波窗口中心</span></span><br><span class="line">	<span class="keyword">int</span> pos = (gaussian_filter_size - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">// 记录滤波窗口所有像素点的权值</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; weight(gaussian_filter_size*gaussian_filter_size, <span class="number">0.0</span>);</span><br><span class="line">	<span class="keyword">double</span> weight_sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gaussian_filter_size; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; gaussian_filter_size; j++) &#123;</span><br><span class="line">			weight[i*gaussian_filter_size + j] = <span class="built_in">exp</span>(-(<span class="built_in">pow</span>(i - pos, <span class="number">2</span>) + <span class="built_in">pow</span>(j - pos, <span class="number">2</span>)) / (<span class="number">2</span> * sigma * sigma)) / (<span class="number">2</span> * PI * sigma*sigma);</span><br><span class="line">			weight_sum += weight[i*gaussian_filter_size + j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 权值归一化</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; gaussian_filter_size*gaussian_filter_size; index++)</span><br><span class="line">		weight[index] /= weight_sum;</span><br><span class="line">	<span class="comment">// 这样我们就得到了归一化后的高斯模板权值</span></span><br><span class="line">	<span class="comment">// 从图片矩阵左上角开始从左到右从上到下使用滤波窗口处理图片矩阵,每次提取filter_size*filter_size的数据进入滤波窗口,利用二维高斯函数计算权值,然后将滤波窗口权值归一化,用权值计算出用来替代滤波窗口中心的像素值</span></span><br><span class="line">	<span class="comment">// 图片按每个通道来处理</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; channel; k++) &#123;</span><br><span class="line">		<span class="comment">// 每个滤波窗口中心位置都计算滤波窗口内通道值的高斯加权平均值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> m = pos; m &lt; row - pos; m++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> n = pos; n &lt; col - pos; n++) &#123;</span><br><span class="line">				<span class="comment">// 使用归一化后的权重计算最终加权得到的像素值,用centerpointValue用来记录</span></span><br><span class="line">				<span class="keyword">double</span> centerpointValue = <span class="number">0</span>;</span><br><span class="line">				<span class="comment">// 将高斯滤波窗口中每个点的加权值和其像素值相乘再相加,得到的和就是滤波窗口中心点的像素值</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = m - (gaussian_filter_size - <span class="number">1</span>) / <span class="number">2</span>; i &lt;= m + (gaussian_filter_size - <span class="number">1</span>) / <span class="number">2</span>; i++) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = n - (gaussian_filter_size - <span class="number">1</span>) / <span class="number">2</span>; j &lt;= n + (gaussian_filter_size - <span class="number">1</span>) / <span class="number">2</span>; j++) &#123;</span><br><span class="line">						<span class="keyword">int</span> index = (i - (m - (gaussian_filter_size - <span class="number">1</span>) / <span class="number">2</span>))*gaussian_filter_size + (j - (n - (gaussian_filter_size - <span class="number">1</span>) / <span class="number">2</span>));</span><br><span class="line">						centerpointValue += weight[index] * <span class="keyword">int</span>(pScr.at&lt;Vec3b&gt;(i, j)[k]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				pScr.at&lt;Vec3b&gt;(m, n)[k] = <span class="keyword">int</span>(centerpointValue);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	imwrite(save_path_gaussian_filter, pScr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先对x方向进行高斯滤波,再对y方向进行高斯滤波,既可以对灰度图像,也可以对彩色图像</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">separate_gaussian_filter</span><span class="params">(<span class="built_in">string</span> load_path, <span class="keyword">int</span> gaussian_filter_size, <span class="keyword">double</span> sigma, <span class="built_in">string</span> save_path_separate_gaussian_filter)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.1415926</span>;</span><br><span class="line">	<span class="comment">// 滤波窗口尺寸必须为奇数</span></span><br><span class="line">	Mat pScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> row = pScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = pScr.cols;</span><br><span class="line">	<span class="keyword">int</span> channel = pScr.channels();</span><br><span class="line">	<span class="comment">//imshow("picture", pScr);</span></span><br><span class="line">	<span class="comment">//waitKey(0);</span></span><br><span class="line">	<span class="comment">//destroyAllWindows();</span></span><br><span class="line">	<span class="comment">// 滤波窗口中心</span></span><br><span class="line">	<span class="keyword">int</span> pos = (gaussian_filter_size - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">// 计算高斯滤波窗口中每个位置的权值</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; weight(gaussian_filter_size*gaussian_filter_size, <span class="number">0.0</span>);</span><br><span class="line">	<span class="keyword">double</span> weight_sum = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 每个滤波窗口记录权重，并记录权值和用来归一化</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gaussian_filter_size; i++) &#123;</span><br><span class="line">		weight[i] = <span class="built_in">exp</span>(-<span class="built_in">pow</span>(i - pos, <span class="number">2</span>) / (<span class="number">2</span> * sigma * sigma)) / (sigma*<span class="built_in">sqrt</span>(<span class="number">2</span> * PI));</span><br><span class="line">		weight_sum += weight[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 权值归一化</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gaussian_filter_size; i++)</span><br><span class="line">		weight[i] /= weight_sum;</span><br><span class="line">	<span class="comment">// 先对水平方向进行高斯滤波</span></span><br><span class="line">	<span class="comment">// 图片按每个通道来处理</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; channel; k++) &#123;</span><br><span class="line">		<span class="comment">// 对每行上进行高斯滤波</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> m = pos; m &lt; col - pos; m++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; row; n++) &#123;</span><br><span class="line">				<span class="keyword">double</span> centerpointValue = <span class="number">0.0</span>;</span><br><span class="line">				<span class="comment">// 计算每个中心点的像素值</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = m - (gaussian_filter_size - <span class="number">1</span>) / <span class="number">2</span>; i &lt;= m + (gaussian_filter_size - <span class="number">1</span>) / <span class="number">2</span>; i++) &#123;</span><br><span class="line">					centerpointValue += weight[i - (m - (gaussian_filter_size - <span class="number">1</span>) / <span class="number">2</span>)] * <span class="keyword">int</span>(pScr.at&lt;Vec3b&gt;(n, i)[k]);</span><br><span class="line">				&#125;</span><br><span class="line">				pScr.at&lt;Vec3b&gt;(n, m)[k] = <span class="keyword">int</span>(centerpointValue);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 再对竖直方向进行高斯滤波</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; channel; k++) &#123;</span><br><span class="line">		<span class="comment">// 对每列上进行高斯滤波</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; col; n++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> m = pos; m &lt; row - pos; m++) &#123;</span><br><span class="line">				<span class="keyword">double</span> centerpointValue = <span class="number">0.0</span>;</span><br><span class="line">				<span class="comment">// 计算每个中心点的像素值</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = m - (gaussian_filter_size - <span class="number">1</span>) / <span class="number">2</span>; i &lt;= m + (gaussian_filter_size - <span class="number">1</span>) / <span class="number">2</span>; i++) &#123;</span><br><span class="line">					centerpointValue += weight[i - (m - (gaussian_filter_size - <span class="number">1</span>) / <span class="number">2</span>)] * <span class="keyword">int</span>(pScr.at&lt;Vec3b&gt;(i, n)[k]);</span><br><span class="line">				&#125;</span><br><span class="line">				pScr.at&lt;Vec3b&gt;(m, n)[k] = <span class="keyword">int</span>(centerpointValue);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	imwrite(save_path_separate_gaussian_filter, pScr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一阶差分就是离散函数中连续两项之差,当自变量从x变到x+1时,函数y(x)在点x的一阶差分∆y(x)=y(x+1)-y(x)</span></span><br><span class="line"><span class="comment">// 二阶差分就是一阶差分的连续两项之差,当自变量从x变到x+1时，函数y=y(x)一阶差分的差分为∆(∆y(x))=∆y(x+1)-∆y(x)=(y(x+2)-y(x+1))-(y(x+1)-y(x))=y(x+2)-2y(x+1)+y(x)</span></span><br><span class="line"><span class="comment">// 分别对Laplace算子x,y两个方向的二阶导数进行差分就得到了离散函数的拉普拉斯算子(Laplacian):f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)</span></span><br><span class="line"><span class="comment">// 这是最基本的拉普拉斯模板a,即像素点的上下左右系数为1,再减去4倍的本像素点像素值;扩展模板b是像素点周围8个点系数为1,再减去8倍的本像素点像素值</span></span><br><span class="line"><span class="comment">// 还有模板c像素点的上下左右系数为-1,再加上4倍的本像素点像素值;模板d是像素点周围8个点系数为-1,再加上8倍的本像素点像素值</span></span><br><span class="line"><span class="comment">// 模板得到的是二阶差分结果,再用原图像像素值根据掩膜中心系数为1还是-1加上一个掩膜中心系数乘以二阶差分的结果</span></span><br><span class="line"><span class="comment">// 拉普拉斯算子可增强图像中灰度突变的区域，减弱灰度的缓慢变化区域</span></span><br><span class="line"><span class="comment">// 选择拉普拉斯算子对原图像进行处理,可产生描述灰度突变的图像,再将拉普拉斯图像与原始图像叠加而产生锐化图像</span></span><br><span class="line"><span class="comment">// 注意拉普拉斯结果的像素值范围可能落在了[0,255]之外,而计算机在显示的时候将赋值全部置为0,大于255的像素全部显示成255</span></span><br><span class="line"><span class="comment">// 因为图像中的边缘就是那些灰度发生跳变的区域，所以拉普拉斯锐化模板在边缘检测中很有用</span></span><br><span class="line"><span class="comment">// 简单来说,拉普拉斯算子可以使黑区域的亮点更亮,白区域的暗点更暗</span></span><br><span class="line"><span class="comment">// 同梯度算子一样，拉普拉斯算子也会增强图像中的噪声，有时用拉普拉斯算子进行边缘检测时，可将图像先进行平滑处理</span></span><br><span class="line"><span class="comment">// 拉普拉斯算子,既可以对灰度图像,也可以对彩色图像</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">laplacian</span><span class="params">(<span class="built_in">string</span> load_path, <span class="built_in">string</span> save_path_laplacian)</span> </span>&#123;</span><br><span class="line">	Mat pScr, res;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> row = pScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = pScr.cols;</span><br><span class="line">	<span class="keyword">int</span> channel = pScr.channels();</span><br><span class="line">	<span class="comment">//imshow("picture", pScr);</span></span><br><span class="line">	<span class="comment">//waitKey(0);</span></span><br><span class="line">	<span class="comment">//destroyAllWindows();</span></span><br><span class="line">	<span class="comment">// 锐化后的图像像素值g(x,y)=f(x,y)+或-二阶差分值(即filter2D)计算后的结果,这里是-</span></span><br><span class="line">	Mat kernel = (Mat_&lt;<span class="keyword">float</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-4</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// 使用上面的核中的权重对图像中每个像素点的像素值进行卷积计算时与下面拉普拉斯函数效果相同</span></span><br><span class="line">	filter2D(pScr, res, pScr.depth(), kernel);</span><br><span class="line">	<span class="comment">// 使用拉普拉斯函数进行锐化,ksize=1时拉普拉斯算子是0,1,0,1,-4,1,0,1,0</span></span><br><span class="line">	<span class="comment">//Laplacian(pScr, res, CV_16S, 1);</span></span><br><span class="line">	<span class="comment">// 将CV_16S型图像转为CV_8U型图像</span></span><br><span class="line">	<span class="comment">//convertScaleAbs(res, res);</span></span><br><span class="line">	imwrite(save_path_laplacian, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任意一对互相垂直方向上(即斜对角)的差分可以看成求梯度的近似方法,Robert算子是利用这种原理,采用对角方向相邻两像素值之差代替该梯度值</span></span><br><span class="line"><span class="comment">// 假设当前点(x,y)在x方向的梯度为gx,在y方向上的梯度为gy</span></span><br><span class="line"><span class="comment">// 那么当前点的总梯度长度为根号下(gx的平方+gy的平方)</span></span><br><span class="line"><span class="comment">// 但是上面的式子计算比较复杂,我们将总梯度长度简化为|gx|+|gy|</span></span><br><span class="line"><span class="comment">// 我们用gx=f(x,y)-f(x+1,y+1),gy=f(x+1,y)-f(x,y+1)来近似代表x方向和y方向上的梯度</span></span><br><span class="line"><span class="comment">// 所以Robert模板的权重为0,0,0,0,-1,0,0,0,1和0,0,0,0,0,-1,0,1,0</span></span><br><span class="line"><span class="comment">// robert算子,既可以对灰度图像,也可以对彩色图像</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">robert</span><span class="params">(<span class="built_in">string</span> load_path, <span class="built_in">string</span> save_path_robert)</span> </span>&#123;</span><br><span class="line">	Mat pScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> row = pScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = pScr.cols;</span><br><span class="line">	<span class="keyword">int</span> channel = pScr.channels();</span><br><span class="line">	<span class="comment">//imshow("picture", pScr);</span></span><br><span class="line">	<span class="comment">//waitKey(0);</span></span><br><span class="line">	<span class="comment">//destroyAllWindows();</span></span><br><span class="line">	<span class="comment">// 滤波窗口中心</span></span><br><span class="line">	<span class="keyword">int</span> pos = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; kernel_1 = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span> &#125;;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; kernel_2 = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">// 从图片矩阵左上角开始从左到右从上到下使用滤波窗口处理图片矩阵,每次提取filter_size*filter_size的数据进入滤波窗口,计算平均值,然后替代滤波窗口中心值</span></span><br><span class="line">	<span class="comment">// 图片按每个通道来处理</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; channel; k++) &#123;</span><br><span class="line">		<span class="comment">// 每个滤波窗口中心位置都计算滤波窗口内通道值的平均值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> m = pos; m &lt; row - pos; m++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> n = pos; n &lt; col - pos; n++) &#123;</span><br><span class="line">				<span class="keyword">int</span> centerpointValue_1 = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">int</span> centerpointValue_2 = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++)</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &lt;= n + <span class="number">1</span>; j++)</span><br><span class="line">						centerpointValue_1 += kernel_1[(i - (m - <span class="number">1</span>)) * <span class="number">3</span> + (j - (n - <span class="number">1</span>))] * <span class="keyword">int</span>(pScr.at&lt;Vec3b&gt;(i, j)[k]);</span><br><span class="line">				centerpointValue_1 = <span class="built_in">abs</span>(centerpointValue_1);</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++)</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &lt;= n + <span class="number">1</span>; j++)</span><br><span class="line">						centerpointValue_2 += kernel_2[(i - (m - <span class="number">1</span>)) * <span class="number">3</span> + (j - (n - <span class="number">1</span>))] * <span class="keyword">int</span>(pScr.at&lt;Vec3b&gt;(i, j)[k]);</span><br><span class="line">				centerpointValue_2 = <span class="built_in">abs</span>(centerpointValue_2);</span><br><span class="line">				pScr.at&lt;Vec3b&gt;(m, n)[k] = centerpointValue_1 + centerpointValue_2;</span><br><span class="line">				<span class="keyword">if</span> (pScr.at&lt;Vec3b&gt;(m, n)[k] &gt; <span class="number">255</span>)</span><br><span class="line">					pScr.at&lt;Vec3b&gt;(m, n)[k] = <span class="number">255</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (pScr.at&lt;Vec3b&gt;(m, n)[k] &lt; <span class="number">0</span>)</span><br><span class="line">					pScr.at&lt;Vec3b&gt;(m, n)[k] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	imwrite(save_path_robert, pScr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sobel算子和Robert算子计算方法类似,也使用gx和gy的近似值代替x方向和y方向上的梯度,总梯度也使用|gx|+|gy|</span></span><br><span class="line"><span class="comment">// gx模板-1,0,1,-2,0,2,-1,0,1,gy模板-1,-2,-1,0,0,0,1,2,1</span></span><br><span class="line"><span class="comment">// 这两个模板作卷积矩阵前要旋转180度，即gx=1,0,-1,2,0,-2,1,0,-1,gy=1,2,1,0,0,0,-1,-2,-1</span></span><br><span class="line"><span class="comment">// sobel算子,既可以对灰度图像,也可以对彩色图像 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sobel</span><span class="params">(<span class="built_in">string</span> load_path, <span class="built_in">string</span> save_path_sobel)</span> </span>&#123;</span><br><span class="line">	Mat pScr, grad_x, grad_y, abs_grad_x, abs_grad_y, grad;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> row = pScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = pScr.cols;</span><br><span class="line">	<span class="keyword">int</span> channel = pScr.channels();</span><br><span class="line">	<span class="comment">//imshow("picture", pScr);</span></span><br><span class="line">	<span class="comment">//waitKey(0);</span></span><br><span class="line">	<span class="comment">//destroyAllWindows();</span></span><br><span class="line">	<span class="comment">// 求x方向梯度</span></span><br><span class="line">	<span class="comment">// 第一个1,0表示在x方向求导,不在y方向求导,ksize=3是sobel算子大小,1是scale,0是delta</span></span><br><span class="line">	Sobel(pScr, grad_x, CV_16S, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, BORDER_DEFAULT);</span><br><span class="line">	<span class="comment">// 转成CV_8U型图像</span></span><br><span class="line">	convertScaleAbs(grad_x, abs_grad_x);</span><br><span class="line">	<span class="comment">// 求y方向梯度</span></span><br><span class="line">	Sobel(pScr, grad_y, CV_16S, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, BORDER_DEFAULT);</span><br><span class="line">	convertScaleAbs(grad_y, abs_grad_y);</span><br><span class="line">	<span class="comment">/// 合并梯度(近似)</span></span><br><span class="line">	addWeighted(abs_grad_x, <span class="number">0.5</span>, abs_grad_y, <span class="number">0.5</span>, <span class="number">0</span>, grad);</span><br><span class="line">	imwrite(save_path_sobel, grad);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 锐化图像得s(x,y)。 </span></span><br><span class="line"><span class="comment">// 从原图像中减去锐化图像，产生的差值图像称为模板G(x,y)=f(x,y)-s(x,y)</span></span><br><span class="line"><span class="comment">// 将模板加到原图像中G(x,y)=p*f(x,y)-k*G(x,y)=(p-1)*f(x,y)+k*s(x,y)</span></span><br><span class="line"><span class="comment">// 当K=1时，为非锐化掩蔽;当k &gt; 1时，高提升滤波，系数越大对细节的增强越明显;当k &lt; 1时，不强调非锐化模板的贡献</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//p是高提升滤波中原图像的混合比例,enhance_filter_size是高提升滤波模板的尺寸(长宽相等),k是模板的混合比例</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enhance_filter</span><span class="params">(<span class="built_in">string</span> load_path, <span class="built_in">string</span> save_path_enhance_filter, <span class="keyword">double</span> p, <span class="keyword">int</span> enhance_filter_size, <span class="keyword">double</span> k, Mat kernel)</span> </span>&#123;</span><br><span class="line">	Mat pScr, res;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> row = pScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = pScr.cols;</span><br><span class="line">	<span class="keyword">int</span> channel = pScr.channels();</span><br><span class="line">	<span class="comment">//imshow("picture", pScr);</span></span><br><span class="line">	<span class="comment">//waitKey(0);</span></span><br><span class="line">	<span class="comment">//destroyAllWindows();</span></span><br><span class="line">	<span class="comment">// 使用上面的核中的权重对图像中每个像素点的像素值进行卷积计算时与下面拉普拉斯函数效果相同</span></span><br><span class="line">	filter2D(pScr, res, pScr.depth(), kernel);</span><br><span class="line">	<span class="comment">// 滤波窗口中心</span></span><br><span class="line">	<span class="keyword">int</span> pos = (enhance_filter_size - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; channel; k++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; row - pos; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = pos; j &lt; col - pos; j++) &#123;</span><br><span class="line">				res.at&lt;Vec3b&gt;(i, j)[k] = <span class="keyword">int</span>((p - <span class="number">1</span>) * pScr.at&lt;Vec3b&gt;(i, j)[k] + k * res.at&lt;Vec3b&gt;(i, j)[k]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	normalize(res, res, <span class="number">0</span>, <span class="number">255</span>, NORM_MINMAX);</span><br><span class="line">	imwrite(save_path_enhance_filter, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> load_path = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/3/save/lenna.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_gray_image = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/3/save/lenna_gray.bmp"</span>;</span><br><span class="line">	<span class="comment">//gray_image(load_path, save_path_gray_image);</span></span><br><span class="line">	<span class="built_in">string</span> load_gray_path = save_path_gray_image;</span><br><span class="line">	<span class="built_in">string</span> save_path_mean_filter_gray_3 = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/3/save/lenna_mean_filter_gray_3.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_mean_filter_color_3 = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/3/save/lenna_mean_filter_color_3.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_mean_filter_gray_5 = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/3/save/lenna_mean_filter_gray_5.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_mean_filter_color_5 = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/3/save/lenna_mean_filter_color_5.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_mean_filter_gray_9 = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/3/save/lenna_mean_filter_gray_9.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_mean_filter_color_9 = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/3/save/lenna_mean_filter_color_9.bmp"</span>;</span><br><span class="line">	<span class="comment">//mean_filter(load_gray_path, 3, save_path_mean_filter_gray_3);</span></span><br><span class="line">	<span class="comment">//mean_filter(load_path, 3, save_path_mean_filter_color_3);</span></span><br><span class="line">	<span class="comment">//mean_filter(load_gray_path, 5, save_path_mean_filter_gray_5);</span></span><br><span class="line">	<span class="comment">//mean_filter(load_path, 5, save_path_mean_filter_color_5);</span></span><br><span class="line">	<span class="comment">//mean_filter(load_gray_path, 9, save_path_mean_filter_gray_9);</span></span><br><span class="line">	<span class="comment">//mean_filter(load_path, 9, save_path_mean_filter_color_9);</span></span><br><span class="line">	<span class="keyword">double</span> sigma = <span class="number">1.5</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_gaussian_filter_gray_3 = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/3/save/lenna_gaussian_filter_gray_3.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_gaussian_filter_color_3 = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/3/save/lenna_gaussian_filter_color_3.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_gaussian_filter_gray_5 = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/3/save/lenna_gaussian_filter_gray_5.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_gaussian_filter_color_5 = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/3/save/lenna_gaussian_filter_color_5.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_gaussian_filter_gray_9 = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/3/save/lenna_gaussian_filter_gray_9.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_gaussian_filter_color_9 = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/3/save/lenna_gaussian_filter_color_9.bmp"</span>;</span><br><span class="line">	gaussian_filter(load_gray_path, <span class="number">3</span>, sigma, save_path_gaussian_filter_gray_3);</span><br><span class="line">	gaussian_filter(load_path, <span class="number">3</span>, sigma, save_path_gaussian_filter_color_3);</span><br><span class="line">	<span class="comment">//separate_gaussian_filter(load_gray_path, 3, sigma, save_path_gaussian_filter_gray_3);</span></span><br><span class="line">	<span class="comment">//separate_gaussian_filter(load_path, 3, sigma, save_path_gaussian_filter_color_3);</span></span><br><span class="line">	<span class="comment">//separate_gaussian_filter(load_gray_path, 5, sigma, save_path_gaussian_filter_gray_5);</span></span><br><span class="line">	<span class="comment">//separate_gaussian_filter(load_path, 5, sigma, save_path_gaussian_filter_color_5);</span></span><br><span class="line">	<span class="comment">//separate_gaussian_filter(load_gray_path, 9, sigma, save_path_gaussian_filter_gray_9);</span></span><br><span class="line">	<span class="comment">//separate_gaussian_filter(load_path, 9, sigma, save_path_gaussian_filter_color_9);</span></span><br><span class="line">	<span class="built_in">string</span> save_path_laplacian_gray = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/3/save/lenna_laplacian_gray.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_laplacian_color = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/3/save/lenna_laplacian_color.bmp"</span>;</span><br><span class="line">	<span class="comment">//laplacian(load_gray_path, save_path_laplacian_gray);</span></span><br><span class="line">	<span class="comment">//laplacian(load_path, save_path_laplacian_color);</span></span><br><span class="line">	<span class="built_in">string</span> save_path_robert_gray = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/3/save/lenna_robert_gray.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_robert_color = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/3/save/lenna_robert_color.bmp"</span>;</span><br><span class="line">	<span class="comment">//robert(load_gray_path, save_path_robert_gray);</span></span><br><span class="line">	<span class="comment">//robert(load_path, save_path_robert_color);</span></span><br><span class="line">	<span class="built_in">string</span> save_path_sobel_gray = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/3/save/lenna_sobel_gray.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_sobel_color = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/3/save/lenna_sobel_color.bmp"</span>;</span><br><span class="line">	sobel(load_gray_path, save_path_sobel_gray);</span><br><span class="line">	sobel(load_path, save_path_sobel_color);</span><br><span class="line">	Mat kernel = (Mat_&lt;<span class="keyword">float</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-8</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">string</span> save_path_enhance_filter_gray = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/3/save/lenna_enhance_filter_gray.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_enhance_filter_color = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/3/save/lenna_enhance_filter_color.bmp"</span>;</span><br><span class="line">	<span class="comment">//enhance_filter(load_gray_path, save_path_enhance_filter_gray, 2.0, 3, 2.0, kernel);</span></span><br><span class="line">	<span class="comment">//enhance_filter(load_path, save_path_enhance_filter_color, 1.0, 3, 2.0, kernel);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实验四：图像去噪"><a href="#实验四：图像去噪" class="headerlink" title="实验四：图像去噪"></a>实验四：图像去噪</h1><h2 id="实验四内容"><a href="#实验四内容" class="headerlink" title="实验四内容"></a>实验四内容</h2><p>1、均值滤波<br>具体内容：利用OpenCV对灰度图像像素进行操作，分别利用算术均值滤波器、几何均值滤波器、谐波和逆谐波均值滤波器进行图像去噪。模板大小为5x5。（注：请分别为图像添加高斯噪声、胡椒噪声、盐噪声和椒盐噪声，并观察滤波效果）。<br>2、中值滤波<br>具体内容：利用OpenCV对灰度图像像素进行操作，分别利用5x5和9x9尺寸的模板对图像进行中值滤波。（注：请分别为图像添加胡椒噪声、盐噪声和椒盐噪声，并观察滤波效果）。<br>3、自适应均值滤波。<br>具体内容：利用OpenCV对灰度图像像素进行操作，设计自适应局部降低噪声滤波器去噪算法。模板大小7x7（对比该算法的效果和均值滤波器的效果）。<br>4、自适应中值滤波<br>具体内容：利用OpenCV对灰度图像像素进行操作，设计自适应中值滤波算法对椒盐图像进行去噪。模板大小7x7（对比中值滤波器的效果）。<br>5、彩色图像均值滤波<br>具体内容：利用OpenCV对彩色图像RGB三个通道的像素进行操作，利用算术均值滤波器和几何均值滤波器进行彩色图像去噪。模板大小为5x5。</p>
<h2 id="实验四理论知识"><a href="#实验四理论知识" class="headerlink" title="实验四理论知识"></a>实验四理论知识</h2><p><strong>椒噪声、盐噪声、椒盐噪声:</strong><br>椒噪声即确定一个百分比，然后从图像中所有像素点中随机取出这个百分比数量的像素点，令其灰度值为0（黑色）。<br>盐噪声即确定一个百分比，然后从图像中所有像素点中随机取出这个百分比数量的像素点，令其灰度值为255（白色）。<br>椒盐噪声即确定一个百分比，然后从图像中所有像素点中随机取出这个百分比数量的像素点，令其灰度值随机为0（黑色）或255（白色）中的一个值。<br><strong>高斯噪声:</strong><br>Box–Muller变换:<br>基于这种变换，我们便可以得到一个从均匀分布中得到正态分布采样的算法。选取两个服从[0, 1]上均匀分布的随机变量U1和U2，有:<br>$$<br>X=\sqrt{-2 \ln U_{1}} \cos \left(2 \pi U_{2}\right)<br>$$<br>$$<br>Y=\sqrt{-2 \ln U_{1}} \sin \left(2 \pi U_{2}\right)<br>$$<br>则X与Y服从均值为0，方差为1的高斯分布。然后我们输入σ和μ，求Yxσ+μ，结果就是一个服从均值为μ，方差为σ2的高斯分布的噪声。原图每个像素点的像素值加上高斯噪声即为加噪后的图象。<br><strong>算术均值滤波公式:</strong><br>$$<br>f(x, y)=\frac{1}{m n} \sum_{(x, y) \in S_{x y}} g(s, t)<br>$$<br>Sxy表示中心点在（x,y）处，大小为m×n的滤波器窗口。g（s,t）表示原始图像灰度值，f（x,y）表示均值滤波后得到的图像灰度值。均值滤波就是把窗口内的像素点上灰度值全部按权重1相加求和，再除以像素点个数，得到的灰度值就是窗口正中心像素点的灰度值。对于彩色图像，对其三个通道分别执行算术均值滤波即可。<br><strong>几何均值滤波公式:</strong><br>$$<br>f(x, y)=\left[\prod_{(s, t) \in S_{x y} g(s, t)}\right]^{\frac{1}{m n}}<br>$$<br>和算术均值滤波器相比，几何均值滤波器能够更好的取出高斯噪声，并且能够更多的保留图像的边缘信息。但，其对0值是非常敏感的，在滤波器的窗口内只要有一个像素的灰度值为0，就会造成滤波器的输出结果为0。<br>实际实现时如果像素点灰度值为0则不乘，开方的幂次也要相应减1。对于彩色图像，对其三个通道分别执行几何均值滤波即可。<br><strong>谐波均值滤波公式:</strong><br>$$<br>f(x, y)=\frac{m n}{\sum_{(x, y) \in S_{x y}} \frac{1}{g(s, t)}}<br>$$<br>谐波均值滤波器对盐粒噪声（白噪声）效果较好，不适用于胡椒噪声，比较适合处理高斯噪声。<br><strong>逆谐波均值滤波公式:</strong><br>$$<br>f(x, y)=\frac{\sum_{(x, y) \in S_{x y}} g(s, t)^{Q+1}}{\sum_{(x, y) \in S_{x y}} g(s, t)^{Q}}<br>$$<br>Q称为滤波器的阶数，该滤波器可以用来消除椒盐噪声。但是需要不同同时处理盐粒噪声和胡椒噪声，当Q为正时，可以消除胡椒噪声；当Q为负时，消除盐粒噪声。当Q=0时，该滤波器退化为算术均值滤波器；Q=-1时，退化为谐波均值滤波器。<br><strong>中值滤波公式:</strong><br>对mxn大小窗口内所有像素点灰度值按从小到大排序，取中值为窗口正中心的像素点的灰度值。<br>中值滤波对脉冲噪声（如椒盐噪声）有良好的滤除作用，特别是在滤除噪声的同时，能够保护信号的边缘，使之不被模糊。<br><strong>自适应均值滤波公式:</strong><br>先计算4个量:<br>g（x,y）带噪图像在点（x,y）上的值；<br>噪声的方差σ2；<br>Sxy区域内,像素点的局部均值mL；<br>Sxy区域内,像素点的局部方差S2；<br>则自适应均值计算公式为:<br>$$<br>f(x, y)=g(x, y)-\frac{\sigma^{2}}{L^{2}}\left[g(x, y)-m_{L}\right]<br>$$<br><strong>自适应中值滤波公式:</strong><br>自适应中值滤波器运行两个进程A,B；<br>过程A确定当前窗口内得到的中值Zmed是否是噪声。如果Zmin&lt;Zmed&lt;Zmax，则中值Zmed不是噪声，这时转到过程B测试，当前窗口的中心位置的像素Zxy是否是一个噪声点。如果Zmin&lt;Zxy&lt;Zmax，则Zxy不是一个噪声，此时滤波器输出Zxy；如果不满足上述条件，则可判定Zxy是噪声，这是输出中值Zmed（在A中已经判断出Zmed不是噪声）。<br>如果在过程A中，得到则Zmed不符合条件Zmin&lt;Zmed&lt;Zmax，则可判断得到的中值Zmed是一个噪声。在这种情况下，需要增大滤波器的窗口尺寸，在一个更大的范围内寻找一个非噪声点的中值，直到找到一个非噪声的中值，跳转到B；或者，窗口的尺寸达到了最大值，这时返回找到的中值，退出。</p>
<h2 id="实验四代码"><a href="#实验四代码" class="headerlink" title="实验四代码"></a>实验四代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt; //包含imread, imshow等</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt; //包含cvtColor等</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gray_image</span><span class="params">(<span class="built_in">string</span> load_path, <span class="built_in">string</span> save_path_gray_image)</span> </span>&#123;</span><br><span class="line">	Mat graypScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	graypScr = imread(load_path, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//imshow("gray_picture", graypScr);</span></span><br><span class="line">	<span class="comment">//waitKey(0);</span></span><br><span class="line">	<span class="comment">//destroyAllWindows();</span></span><br><span class="line">	imwrite(save_path_gray_image, graypScr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 盐噪声其实就是使图像的一些随机的像素为白色(255),胡椒噪声就是使图像的一些随机的像素为黑色(0)</span></span><br><span class="line"><span class="comment">// 盐椒噪声就是在使图像中一些随机的像素为黑色(0)或白色(255)</span></span><br><span class="line"><span class="comment">// 盐噪声</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">salt</span><span class="params">(<span class="built_in">string</span> load_path, <span class="built_in">string</span> save_path_salt, <span class="keyword">double</span> percent)</span> </span>&#123;</span><br><span class="line">	Mat pScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> row = pScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = pScr.cols;</span><br><span class="line">	<span class="keyword">int</span> channel = pScr.channels();</span><br><span class="line">	<span class="keyword">int</span> num = <span class="keyword">int</span>(percent*row*col);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; num; n++) &#123;</span><br><span class="line">		<span class="comment">// i,j为像素点坐标</span></span><br><span class="line">		<span class="keyword">int</span> i = rand() % row;</span><br><span class="line">		<span class="keyword">int</span> j = rand() % col;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; channel; k++) &#123;</span><br><span class="line">			pScr.at&lt;Vec3b&gt;(i, j)[k] = <span class="number">255</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	imwrite(save_path_salt, pScr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 胡椒噪声</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pepper</span><span class="params">(<span class="built_in">string</span> load_path, <span class="built_in">string</span> save_path_pepper, <span class="keyword">double</span> percent)</span> </span>&#123;</span><br><span class="line">	Mat pScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> row = pScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = pScr.cols;</span><br><span class="line">	<span class="keyword">int</span> channel = pScr.channels();</span><br><span class="line">	<span class="keyword">int</span> num = <span class="keyword">int</span>(percent*row*col);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; num; n++) &#123;</span><br><span class="line">		<span class="comment">// i,j为像素点坐标</span></span><br><span class="line">		<span class="keyword">int</span> i = rand() % row;</span><br><span class="line">		<span class="keyword">int</span> j = rand() % col;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; channel; k++) &#123;</span><br><span class="line">			pScr.at&lt;Vec3b&gt;(i, j)[k] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	imwrite(save_path_pepper, pScr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 椒盐噪声</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">peppersalt</span><span class="params">(<span class="built_in">string</span> load_path, <span class="built_in">string</span> save_path_peppersalt, <span class="keyword">double</span> percent)</span> </span>&#123;</span><br><span class="line">	Mat pScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> row = pScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = pScr.cols;</span><br><span class="line">	<span class="keyword">int</span> channel = pScr.channels();</span><br><span class="line">	<span class="keyword">int</span> num = <span class="keyword">int</span>(percent*row*col);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; num; n++) &#123;</span><br><span class="line">		<span class="comment">// i,j为像素点坐标</span></span><br><span class="line">		<span class="keyword">int</span> i = rand() % row;</span><br><span class="line">		<span class="keyword">int</span> j = rand() % col;</span><br><span class="line">		<span class="keyword">int</span> flag = rand() % <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; channel; k++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">				pScr.at&lt;Vec3b&gt;(i, j)[k] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">				pScr.at&lt;Vec3b&gt;(i, j)[k] = <span class="number">255</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	imwrite(save_path_peppersalt, pScr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Box–Muller变换是一种从一个均匀分布中得到正态分布采样的算法</span></span><br><span class="line"><span class="comment">// 选取两个服从[0, 1]上均匀分布的随机变量U1和U2,X=cos(2πU1)*sqrt(−2lnU2),Y=sin(2πU1)*sqrt(−2lnU2)</span></span><br><span class="line"><span class="comment">// 则X与Y服从均值为0，方差为1的高斯分布</span></span><br><span class="line"><span class="comment">// 生成高斯噪声,mu是均值,sigma是方差,X服从N(0,1)分布 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">generategaussiannoise</span><span class="params">(<span class="keyword">double</span> mu, <span class="keyword">double</span> sigma)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义一个特别小的值</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> epsilon = numeric_limits&lt;<span class="keyword">double</span>&gt;::min();<span class="comment">//返回目标数据类型能表示的最逼近1的正数和1的差的绝对值</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">double</span> z0, z1;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">	flag = !flag;</span><br><span class="line">	<span class="comment">//flag为假，构造高斯随机变量</span></span><br><span class="line">	<span class="keyword">if</span> (!flag)</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">int</span>(z1 * sigma + mu);</span><br><span class="line">	<span class="keyword">double</span> u1, u2;</span><br><span class="line">	<span class="comment">//构造随机变量</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		u1 = rand()*(<span class="number">1.0</span> / RAND_MAX);</span><br><span class="line">		u2 = rand()*(<span class="number">1.0</span> / RAND_MAX);</span><br><span class="line">	&#125; <span class="keyword">while</span> (u1 &lt;= epsilon);</span><br><span class="line">	<span class="comment">//flag为真构造高斯随机变量X</span></span><br><span class="line">	z0 = <span class="built_in">sqrt</span>(<span class="number">-2.0</span>*<span class="built_in">log</span>(u1))*<span class="built_in">cos</span>(<span class="number">2</span> * CV_PI * u2);</span><br><span class="line">	z1 = <span class="built_in">sqrt</span>(<span class="number">-2.0</span>*<span class="built_in">log</span>(u1))*<span class="built_in">sin</span>(<span class="number">2</span> * CV_PI * u2);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">int</span>(z1 * sigma + mu);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原图每个像素点的像素值加上高斯噪声即为加噪后的图象</span></span><br><span class="line"><span class="comment">// k可取16,32,64,128,256</span></span><br><span class="line"><span class="comment">// sigma可取0.1,0.5,1.0,2.0,5.0</span></span><br><span class="line"><span class="comment">// k为高斯噪声的系数,系数越大,高斯噪声越强;噪声服从高斯分布,所以方差越大,数据越分散,噪声也就越多</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addgaussiannoise</span><span class="params">(<span class="built_in">string</span> load_path, <span class="built_in">string</span> save_path_gaussiannoise, <span class="keyword">double</span> mu, <span class="keyword">double</span> sigma, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	Mat pScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> row = pScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = pScr.cols;</span><br><span class="line">	<span class="keyword">int</span> channel = pScr.channels();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; channel; k++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">				pScr.at&lt;Vec3b&gt;(i, j)[k] = pScr.at&lt;Vec3b&gt;(i, j)[k] + generategaussiannoise(mu, sigma) * k;</span><br><span class="line">				<span class="keyword">if</span> (pScr.at&lt;Vec3b&gt;(i, j)[k] &gt; <span class="number">255</span>)</span><br><span class="line">					pScr.at&lt;Vec3b&gt;(i, j)[k] = <span class="number">255</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (pScr.at&lt;Vec3b&gt;(i, j)[k] &lt; <span class="number">0</span>)</span><br><span class="line">					pScr.at&lt;Vec3b&gt;(i, j)[k] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	imwrite(save_path_gaussiannoise, pScr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算术平均值滤波,既可以对灰度图像,也可以对彩色图像</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">arithmetic_mean_filter</span><span class="params">(<span class="built_in">string</span> load_path, <span class="keyword">int</span> arithmetic_mean_filter_size, <span class="built_in">string</span> save_path_arithmetic_mean_filter)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 滤波窗口尺寸必须为奇数</span></span><br><span class="line">	Mat pScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> row = pScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = pScr.cols;</span><br><span class="line">	<span class="keyword">int</span> channel = pScr.channels();</span><br><span class="line">	<span class="comment">//imshow("picture", pScr);</span></span><br><span class="line">	<span class="comment">//waitKey(0);</span></span><br><span class="line">	<span class="comment">//destroyAllWindows();</span></span><br><span class="line">	<span class="comment">// 滤波窗口中心</span></span><br><span class="line">	<span class="keyword">int</span> pos = (arithmetic_mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">// 从图片矩阵左上角开始从左到右从上到下使用滤波窗口处理图片矩阵,每次提取filter_size*filter_size的数据进入滤波窗口,计算平均值,然后替代滤波窗口中心值</span></span><br><span class="line">	<span class="comment">// 图片按每个通道来处理</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; channel; k++) &#123;</span><br><span class="line">		<span class="comment">// 每个滤波窗口中心位置都计算滤波窗口内通道值的平均值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> m = pos; m &lt; row - pos; m++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> n = pos; n &lt; col - pos; n++) &#123;</span><br><span class="line">				<span class="keyword">int</span> centerpointValue = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = m - (arithmetic_mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>; i &lt;= m + (arithmetic_mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>; i++)</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = n - (arithmetic_mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>; j &lt;= n + (arithmetic_mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>; j++)</span><br><span class="line">						centerpointValue += <span class="keyword">int</span>(pScr.at&lt;Vec3b&gt;(i, j)[k]);</span><br><span class="line">				centerpointValue = <span class="keyword">int</span>(centerpointValue / (arithmetic_mean_filter_size*arithmetic_mean_filter_size));</span><br><span class="line">				pScr.at&lt;Vec3b&gt;(m, n)[k] = centerpointValue;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	imwrite(save_path_arithmetic_mean_filter, pScr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 几何平均值滤波,既可以对灰度图像,也可以对彩色图像</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">geometric_mean_filter</span><span class="params">(<span class="built_in">string</span> load_path, <span class="keyword">int</span> geometric_mean_filter_size, <span class="built_in">string</span> save_path_geometric_mean_filter)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 滤波窗口尺寸必须为奇数</span></span><br><span class="line">	Mat pScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> row = pScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = pScr.cols;</span><br><span class="line">	<span class="keyword">int</span> channel = pScr.channels();</span><br><span class="line">	<span class="comment">//imshow("picture", pScr);</span></span><br><span class="line">	<span class="comment">//waitKey(0);</span></span><br><span class="line">	<span class="comment">//destroyAllWindows();</span></span><br><span class="line">	<span class="comment">// 滤波窗口中心</span></span><br><span class="line">	<span class="keyword">int</span> pos = (geometric_mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">// 从图片矩阵左上角开始从左到右从上到下使用滤波窗口处理图片矩阵,每次提取filter_size*filter_size的数据进入滤波窗口,计算平均值,然后替代滤波窗口中心值</span></span><br><span class="line">	<span class="comment">// 图片按每个通道来处理</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; channel; k++) &#123;</span><br><span class="line">		<span class="comment">// 每个滤波窗口中心位置都计算滤波窗口内通道值的平均值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> m = pos; m &lt; row - pos; m++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> n = pos; n &lt; col - pos; n++) &#123;</span><br><span class="line">				<span class="keyword">double</span> centerpointValue = <span class="number">1.0</span>;</span><br><span class="line">				<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = m - (geometric_mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>; i &lt;= m + (geometric_mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>; i++)</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = n - (geometric_mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>; j &lt;= n + (geometric_mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>; j++) &#123;</span><br><span class="line">						<span class="keyword">if</span> (pScr.at&lt;Vec3b&gt;(i, j)[k] != <span class="number">0</span>) &#123;</span><br><span class="line">							centerpointValue *= <span class="keyword">int</span>(pScr.at&lt;Vec3b&gt;(i, j)[k]);</span><br><span class="line">							count++;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				centerpointValue = <span class="built_in">pow</span>(centerpointValue, <span class="number">1.0</span> / count);</span><br><span class="line">				pScr.at&lt;Vec3b&gt;(m, n)[k] = <span class="keyword">int</span>(centerpointValue);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	imwrite(save_path_geometric_mean_filter, pScr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 谐波均值滤波</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">harmonic_mean_filter</span><span class="params">(<span class="built_in">string</span> load_path, <span class="keyword">int</span> harmonic_mean_filter_size, <span class="built_in">string</span> save_path_harmonic_mean_filter)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 滤波窗口尺寸必须为奇数</span></span><br><span class="line">	Mat pScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> row = pScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = pScr.cols;</span><br><span class="line">	<span class="keyword">int</span> channel = pScr.channels();</span><br><span class="line">	<span class="keyword">int</span> pos = (harmonic_mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">// 从图片矩阵左上角开始从左到右从上到下使用滤波窗口处理图片矩阵,每次提取filter_size*filter_size的数据进入滤波窗口,计算平均值,然后替代滤波窗口中心值</span></span><br><span class="line">	<span class="comment">// 图片按每个通道来处理</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; channel; k++) &#123;</span><br><span class="line">		<span class="comment">// 每个滤波窗口中心位置都计算滤波窗口内通道值的平均值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> m = pos; m &lt; row - pos; m++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> n = pos; n &lt; col - pos; n++) &#123;</span><br><span class="line">				<span class="keyword">double</span> centerpointValue = <span class="number">0.0</span>;</span><br><span class="line">				<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = m - (harmonic_mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>; i &lt;= m + (harmonic_mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>; i++)</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = n - (harmonic_mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>; j &lt;= n + (harmonic_mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>; j++) &#123;</span><br><span class="line">						<span class="keyword">if</span> (pScr.at&lt;Vec3b&gt;(i, j)[k] != <span class="number">0</span>) &#123;</span><br><span class="line">							centerpointValue += <span class="number">1.0</span> / <span class="keyword">int</span>(pScr.at&lt;Vec3b&gt;(i, j)[k]);</span><br><span class="line">							count++;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				centerpointValue = count / centerpointValue;</span><br><span class="line">				pScr.at&lt;Vec3b&gt;(m, n)[k] = <span class="keyword">int</span>(centerpointValue);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	imwrite(save_path_harmonic_mean_filter, pScr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逆谐波均值滤波</span></span><br><span class="line"><span class="comment">// Q为滤波器的阶数,当Q为正时，可以消除胡椒噪声;当Q为负时,消除盐粒噪声;当Q=0时，该滤波器退化为算术均值滤波器;Q = -1时,退化为谐波均值滤波器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inverse_harmonic_mean_filter</span><span class="params">(<span class="built_in">string</span> load_path, <span class="keyword">int</span> inverse_harmonic_mean_filter_size, <span class="built_in">string</span> save_path_inverse_harmonic_mean_filter, <span class="keyword">double</span> q)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 滤波窗口尺寸必须为奇数</span></span><br><span class="line">	Mat pScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> row = pScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = pScr.cols;</span><br><span class="line">	<span class="keyword">int</span> channel = pScr.channels();</span><br><span class="line">	<span class="keyword">int</span> pos = (inverse_harmonic_mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">// 从图片矩阵左上角开始从左到右从上到下使用滤波窗口处理图片矩阵,每次提取filter_size*filter_size的数据进入滤波窗口,计算平均值,然后替代滤波窗口中心值</span></span><br><span class="line">	<span class="comment">// 图片按每个通道来处理</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; channel; k++) &#123;</span><br><span class="line">		<span class="comment">// 每个滤波窗口中心位置都计算滤波窗口内通道值的平均值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> m = pos; m &lt; row - pos; m++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> n = pos; n &lt; col - pos; n++) &#123;</span><br><span class="line">				<span class="keyword">double</span> centerpointValue_1 = <span class="number">0.0</span>;</span><br><span class="line">				<span class="keyword">double</span> centerpointValue_2 = <span class="number">0.0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = m - (inverse_harmonic_mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>; i &lt;= m + (inverse_harmonic_mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>; i++)</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = n - (inverse_harmonic_mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>; j &lt;= n + (inverse_harmonic_mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>; j++) &#123;</span><br><span class="line">						centerpointValue_1 += <span class="built_in">pow</span>(pScr.at&lt;Vec3b&gt;(i, j)[k], q + <span class="number">1.0</span>);</span><br><span class="line">						<span class="keyword">if</span> (pScr.at&lt;Vec3b&gt;(i, j)[k] != <span class="number">0</span>)</span><br><span class="line">							centerpointValue_2 += <span class="built_in">pow</span>(pScr.at&lt;Vec3b&gt;(i, j)[k], q);</span><br><span class="line">					&#125;</span><br><span class="line">				pScr.at&lt;Vec3b&gt;(m, n)[k] = <span class="keyword">int</span>(centerpointValue_1 / centerpointValue_2);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	imwrite(save_path_inverse_harmonic_mean_filter, pScr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中值滤波</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">median_filter</span><span class="params">(<span class="built_in">string</span> load_path, <span class="built_in">string</span> save_path_median_filter, <span class="keyword">int</span> median_filter_size)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 滤波窗口尺寸必须为奇数</span></span><br><span class="line">	Mat pScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> row = pScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = pScr.cols;</span><br><span class="line">	<span class="keyword">int</span> channel = pScr.channels();</span><br><span class="line">	<span class="keyword">int</span> pos = (median_filter_size - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">// 从图片矩阵左上角开始从左到右从上到下使用滤波窗口处理图片矩阵,每次提取filter_size*filter_size的数据进入滤波窗口,计算平均值,然后替代滤波窗口中心值</span></span><br><span class="line">	<span class="comment">// 图片按每个通道来处理</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; channel; k++) &#123;</span><br><span class="line">		<span class="comment">// 每个滤波窗口中心位置都计算滤波窗口内通道值的平均值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> m = pos; m &lt; row - pos; m++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> n = pos; n &lt; col - pos; n++) &#123;</span><br><span class="line">				<span class="keyword">int</span> centerpointValue = <span class="number">0</span>;</span><br><span class="line">				<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; filter_value;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = m - (median_filter_size - <span class="number">1</span>) / <span class="number">2</span>; i &lt;= m + (median_filter_size - <span class="number">1</span>) / <span class="number">2</span>; i++)</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = n - (median_filter_size - <span class="number">1</span>) / <span class="number">2</span>; j &lt;= n + (median_filter_size - <span class="number">1</span>) / <span class="number">2</span>; j++)</span><br><span class="line">						filter_value.push_back(<span class="keyword">int</span>(pScr.at&lt;Vec3b&gt;(i, j)[k]));</span><br><span class="line">				<span class="comment">// 快速排序</span></span><br><span class="line">				sort(filter_value.begin(), filter_value.end());</span><br><span class="line">				pScr.at&lt;Vec3b&gt;(m, n)[k] = filter_value[<span class="keyword">int</span>(median_filter_size*median_filter_size / <span class="number">2</span>)];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	imwrite(save_path_median_filter, pScr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自适应均值滤波</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">self_adapt_mean_filter</span><span class="params">(<span class="built_in">string</span> load_path, <span class="built_in">string</span> save_path_self_adapt_mean_filter, <span class="keyword">int</span> self_adapt_mean_filter_size)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 滤波窗口尺寸必须为奇数</span></span><br><span class="line">	Mat pScr, dst;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> row = pScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = pScr.cols;</span><br><span class="line">	<span class="keyword">int</span> channel = pScr.channels();</span><br><span class="line">	blur(pScr, dst, Size(<span class="number">7</span>, <span class="number">7</span>));</span><br><span class="line">	<span class="keyword">int</span> pos = (self_adapt_mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">double</span> Sn = <span class="number">100.0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; channel; k++) &#123;</span><br><span class="line">		<span class="comment">// 每个滤波窗口中心位置都计算滤波窗口内通道值的平均值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> m = pos; m &lt; row - pos; m++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> n = pos; n &lt; col - pos; n++) &#123;</span><br><span class="line">				<span class="keyword">int</span> Zxy = <span class="keyword">int</span>(pScr.at&lt;Vec3b&gt;(m, n)[k]);</span><br><span class="line">				<span class="keyword">int</span> Zmed = <span class="keyword">int</span>(dst.at&lt;Vec3b&gt;(m, n)[k]);</span><br><span class="line">				<span class="keyword">double</span> Sl = <span class="number">0.0</span>;</span><br><span class="line">				<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = m - (self_adapt_mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>; i &lt;= m + (self_adapt_mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>; i++) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = n - (self_adapt_mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>; j &lt;= n + (self_adapt_mean_filter_size - <span class="number">1</span>) / <span class="number">2</span>; j++) &#123;</span><br><span class="line">						<span class="keyword">int</span> Sxy = pScr.at&lt;Vec3b&gt;(i, j)[k];</span><br><span class="line">						Sl += <span class="built_in">pow</span>(Sxy - Zmed, <span class="number">2</span>);</span><br><span class="line">						count++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				Sl = Sl / count;</span><br><span class="line">				pScr.at&lt;Vec3b&gt;(m, n)[k] = (<span class="keyword">int</span>)(Zxy - Sn / Sl * (Zxy - Zmed));</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	imwrite(save_path_self_adapt_mean_filter, pScr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过程A的目的是确定当前窗口内得到的中值Zmed是否是噪声。如果Zmin&lt;Zmed&lt;Zmax,则中值Zmed不是噪声,此时转到过程B测试当前窗口的中心位置的像素Zxy是否是一个噪声点</span></span><br><span class="line"><span class="comment">// 如果Zmin&lt;Zxy&lt;Zmax,则Zxy不是一个噪声，此时滤波器输出Zxy;如果不满足上述条件，则可判定Zxy是噪声,这时输出中值Zmed(在A中已经判断出Zmed不是噪声)。</span></span><br><span class="line"><span class="comment">// 如果在过程A中，得到Zmed不符合条件Zmin&lt;Zmed&lt;Zmax,则可判断得到的中值Zmed是一个噪声</span></span><br><span class="line"><span class="comment">// 在这种情况下,需要增大滤波器的窗口尺寸,在一个更大的范围内寻找一个非噪声点的中值，直到找到一个非噪声的中值，跳转到B</span></span><br><span class="line"><span class="comment">// 或者，窗口的尺寸达到了最大值，这时返回找到的中值,退出</span></span><br><span class="line"><span class="comment">// 自适应中值滤波</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">self_adapt_median_filter</span><span class="params">(<span class="built_in">string</span> load_path, <span class="built_in">string</span> save_path_self_adapt_median_filter, <span class="keyword">int</span> self_adapt_median_filter_size)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 滤波窗口尺寸必须为奇数</span></span><br><span class="line">	Mat pScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> row = pScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = pScr.cols;</span><br><span class="line">	<span class="keyword">int</span> channel = pScr.channels();</span><br><span class="line">	<span class="comment">// 滤波器窗口的起始尺寸</span></span><br><span class="line">	<span class="keyword">int</span> pos = (self_adapt_median_filter_size - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; channel; k++) &#123;</span><br><span class="line">		<span class="comment">// 每个滤波窗口中心位置都计算滤波窗口内通道值的平均值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> m = pos; m &lt; row - pos; m++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> n = pos; n &lt; col - pos; n++) &#123;</span><br><span class="line">				<span class="keyword">int</span> minValue = <span class="number">255</span>;</span><br><span class="line">				<span class="keyword">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">int</span> medValue = <span class="number">0</span>;</span><br><span class="line">				<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; filter_value;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = m - (self_adapt_median_filter_size - <span class="number">1</span>) / <span class="number">2</span>; i &lt;= m + (self_adapt_median_filter_size - <span class="number">1</span>) / <span class="number">2</span>; i++) &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = n - (self_adapt_median_filter_size - <span class="number">1</span>) / <span class="number">2</span>; j &lt;= n + (self_adapt_median_filter_size - <span class="number">1</span>) / <span class="number">2</span>; j++) &#123;</span><br><span class="line">						filter_value.push_back(<span class="keyword">int</span>(pScr.at&lt;Vec3b&gt;(i, j)[k]));</span><br><span class="line">						<span class="keyword">if</span> (<span class="keyword">int</span>(pScr.at&lt;Vec3b&gt;(i, j)[k]) &gt; maxValue)</span><br><span class="line">							maxValue = <span class="keyword">int</span>(pScr.at&lt;Vec3b&gt;(i, j)[k]);</span><br><span class="line">						<span class="keyword">if</span> (<span class="keyword">int</span>(pScr.at&lt;Vec3b&gt;(i, j)[k]) &lt; minValue)</span><br><span class="line">							minValue = <span class="keyword">int</span>(pScr.at&lt;Vec3b&gt;(i, j)[k]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				sort(filter_value.begin(), filter_value.end());</span><br><span class="line">				medValue = filter_value[<span class="keyword">int</span>(self_adapt_median_filter_size*self_adapt_median_filter_size / <span class="number">2</span>)];</span><br><span class="line">				<span class="keyword">int</span> fxy = <span class="keyword">int</span>(pScr.at&lt;Vec3b&gt;(m, n)[k]);</span><br><span class="line">				<span class="keyword">if</span> (medValue &gt; minValue &amp;&amp; medValue &lt; maxValue)</span><br><span class="line">					<span class="keyword">if</span> (fxy &lt;= minValue || fxy &gt;= maxValue)</span><br><span class="line">						pScr.at&lt;Vec3b&gt;(m, n)[k] = medValue;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">						pScr.at&lt;Vec3b&gt;(m, n)[k] = medValue;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	imwrite(save_path_self_adapt_median_filter, pScr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> load_path = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_gray_image = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_gray.bmp"</span>;</span><br><span class="line">	gray_image(load_path, save_path_gray_image);</span><br><span class="line">	<span class="built_in">string</span> load_gray_path = save_path_gray_image;</span><br><span class="line">	<span class="built_in">string</span> save_path_gray_salt = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_gray_salt.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_color_salt = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_color_salt.bmp"</span>;</span><br><span class="line">	salt(load_gray_path, save_path_gray_salt, <span class="number">0.15</span>);</span><br><span class="line">	salt(load_path, save_path_color_salt, <span class="number">0.15</span>);</span><br><span class="line">	<span class="built_in">string</span> save_path_gray_pepper = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_gray_pepper.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_color_pepper = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_color_pepper.bmp"</span>;</span><br><span class="line">	pepper(load_gray_path, save_path_gray_pepper, <span class="number">0.15</span>);</span><br><span class="line">	pepper(load_path, save_path_color_pepper, <span class="number">0.15</span>);</span><br><span class="line">	<span class="built_in">string</span> save_path_gray_peppersalt = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_gray_peppersalt.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_color_peppersalt = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_color_peppersalt.bmp"</span>;</span><br><span class="line">	peppersalt(load_gray_path, save_path_gray_peppersalt, <span class="number">0.15</span>);</span><br><span class="line">	peppersalt(load_path, save_path_color_peppersalt, <span class="number">0.15</span>);</span><br><span class="line">	<span class="built_in">string</span> save_path_gray_gaussiannoise = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_gray_gaussiannoise.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_color_gaussiannoise = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_color_gaussiannoise.bmp"</span>;</span><br><span class="line">	addgaussiannoise(load_gray_path, save_path_gray_gaussiannoise, <span class="number">1.0</span>, <span class="number">20</span>, <span class="number">32</span>);</span><br><span class="line">	addgaussiannoise(load_path, save_path_color_gaussiannoise, <span class="number">1.0</span>, <span class="number">20</span>, <span class="number">32</span>);</span><br><span class="line">	<span class="built_in">string</span> save_path_arithmetic_mean_filter_salt_gray = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_arithmetic_mean_filter_salt_gray.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_arithmetic_mean_filter_pepper_gray = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_arithmetic_mean_filter_pepper_gray.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_arithmetic_mean_filter_peppersalt_gray = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_arithmetic_mean_filter_peppersalt_gray.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_arithmetic_mean_filter_gaussiannoise_gray = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_arithmetic_mean_filter_gaussiannoise_gray.bmp"</span>;</span><br><span class="line">	arithmetic_mean_filter(save_path_gray_salt, <span class="number">5</span>, save_path_arithmetic_mean_filter_salt_gray);</span><br><span class="line">	arithmetic_mean_filter(save_path_gray_pepper, <span class="number">5</span>, save_path_arithmetic_mean_filter_pepper_gray);</span><br><span class="line">	arithmetic_mean_filter(save_path_gray_peppersalt, <span class="number">5</span>, save_path_arithmetic_mean_filter_peppersalt_gray);</span><br><span class="line">	arithmetic_mean_filter(save_path_gray_gaussiannoise, <span class="number">5</span>, save_path_arithmetic_mean_filter_gaussiannoise_gray);</span><br><span class="line">	<span class="built_in">string</span> save_path_geometric_mean_filter_salt_gray = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_geometric_mean_filter_salt_gray.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_geometric_mean_filter_pepper_gray = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_geometric_mean_filter_pepper_gray.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_geometric_mean_filter_peppersalt_gray = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_geometric_mean_filter_peppersalt_gray.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_geometric_mean_filter_gaussiannoise_gray = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_geometric_mean_filter_gaussiannoise_gray.bmp"</span>;</span><br><span class="line">	geometric_mean_filter(save_path_gray_salt, <span class="number">5</span>, save_path_geometric_mean_filter_salt_gray);</span><br><span class="line">	geometric_mean_filter(save_path_gray_pepper, <span class="number">5</span>, save_path_geometric_mean_filter_pepper_gray);</span><br><span class="line">	geometric_mean_filter(save_path_gray_peppersalt, <span class="number">5</span>, save_path_geometric_mean_filter_peppersalt_gray);</span><br><span class="line">	geometric_mean_filter(save_path_gray_gaussiannoise, <span class="number">5</span>, save_path_geometric_mean_filter_gaussiannoise_gray);</span><br><span class="line">	<span class="built_in">string</span> save_path_harmonic_mean_filter_salt_gray = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_harmonic_mean_filter_salt_gray.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_harmonic_mean_filter_pepper_gray = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_harmonic_mean_filter_pepper_gray.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_harmonic_mean_filter_peppersalt_gray = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_harmonic_mean_filter_peppersalt_gray.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_harmonic_mean_filter_gaussiannoise_gray = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_harmonic_mean_filter_gaussiannoise_gray.bmp"</span>;</span><br><span class="line">	harmonic_mean_filter(save_path_gray_salt, <span class="number">5</span>, save_path_harmonic_mean_filter_salt_gray);</span><br><span class="line">	harmonic_mean_filter(save_path_gray_pepper, <span class="number">5</span>, save_path_harmonic_mean_filter_pepper_gray);</span><br><span class="line">	harmonic_mean_filter(save_path_gray_peppersalt, <span class="number">5</span>, save_path_harmonic_mean_filter_peppersalt_gray);</span><br><span class="line">	harmonic_mean_filter(save_path_gray_gaussiannoise, <span class="number">5</span>, save_path_harmonic_mean_filter_gaussiannoise_gray);</span><br><span class="line">	<span class="built_in">string</span> save_path_inverse_harmonic_mean_filter_salt_gray = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_inverse_harmonic_mean_filter_salt_gray.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_inverse_harmonic_mean_filter_pepper_gray = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_inverse_harmonic_mean_filter_pepper_gray.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_inverse_harmonic_mean_filter_peppersalt_gray = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_inverse_harmonic_mean_filter_peppersalt_gray.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_inverse_harmonic_mean_filter_gaussiannoise_gray = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_inverse_harmonic_mean_filter_gaussiannoise_gray.bmp"</span>;</span><br><span class="line">	inverse_harmonic_mean_filter(save_path_gray_salt, <span class="number">5</span>, save_path_inverse_harmonic_mean_filter_salt_gray, <span class="number">-0.5</span>);</span><br><span class="line">	inverse_harmonic_mean_filter(save_path_gray_pepper, <span class="number">5</span>, save_path_inverse_harmonic_mean_filter_pepper_gray, <span class="number">1.0</span>);</span><br><span class="line">	inverse_harmonic_mean_filter(save_path_gray_peppersalt, <span class="number">5</span>, save_path_inverse_harmonic_mean_filter_peppersalt_gray, <span class="number">0</span>);</span><br><span class="line">	inverse_harmonic_mean_filter(save_path_gray_gaussiannoise, <span class="number">5</span>, save_path_inverse_harmonic_mean_filter_gaussiannoise_gray, <span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">string</span> save_path_median_filter_salt_gray_5 = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_median_filter_salt_gray_5.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_median_filter_pepper_gray_5 = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_median_filter_pepper_gray_5.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_median_filter_peppersalt_gray_5 = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_median_filter_peppersalt_gray_5.bmp"</span>;</span><br><span class="line">	median_filter(save_path_gray_salt, save_path_median_filter_salt_gray_5, <span class="number">5</span>);</span><br><span class="line">	median_filter(save_path_gray_pepper, save_path_median_filter_pepper_gray_5, <span class="number">5</span>);</span><br><span class="line">	median_filter(save_path_gray_peppersalt, save_path_median_filter_peppersalt_gray_5, <span class="number">5</span>);</span><br><span class="line">	<span class="built_in">string</span> save_path_median_filter_salt_gray_9 = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_median_filter_salt_gray_9.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_median_filter_pepper_gray_9 = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_median_filter_pepper_gray_9.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_median_filter_peppersalt_gray_9 = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_median_filter_peppersalt_gray_9.bmp"</span>;</span><br><span class="line">	median_filter(save_path_gray_salt, save_path_median_filter_salt_gray_9, <span class="number">9</span>);</span><br><span class="line">	median_filter(save_path_gray_pepper, save_path_median_filter_pepper_gray_9, <span class="number">9</span>);</span><br><span class="line">	median_filter(save_path_gray_peppersalt, save_path_median_filter_peppersalt_gray_9, <span class="number">9</span>);</span><br><span class="line">	<span class="built_in">string</span> save_path_self_adapt_mean_filter_gray_7 = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_self_adapt_mean_filter_gray_7.bmp"</span>;</span><br><span class="line">	arithmetic_mean_filter(load_gray_path, <span class="number">7</span>, save_path_arithmetic_mean_filter_salt_gray);</span><br><span class="line">	self_adapt_mean_filter(load_gray_path, save_path_self_adapt_mean_filter_gray_7, <span class="number">7</span>);</span><br><span class="line">	<span class="built_in">string</span> save_path_median_filter_peppersalt_gray_7 = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_median_filter_peppersalt_gray_7.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_self_adapt_median_filter_gray_7 = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_self_adapt_median_filter_gray_7.bmp"</span>;</span><br><span class="line">	median_filter(save_path_gray_peppersalt, save_path_median_filter_peppersalt_gray_7, <span class="number">7</span>);</span><br><span class="line">	self_adapt_median_filter(save_path_gray_peppersalt, save_path_self_adapt_median_filter_gray_7, <span class="number">7</span>);</span><br><span class="line">	<span class="built_in">string</span> save_path_arithmetic_mean_filter_salt_color = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_arithmetic_mean_filter_salt_color.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_arithmetic_mean_filter_pepper_color = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_arithmetic_mean_filter_pepper_color.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_arithmetic_mean_filter_peppersalt_color = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_arithmetic_mean_filter_peppersalt_color.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_arithmetic_mean_filter_gaussiannoise_color = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_arithmetic_mean_filter_gaussiannoise_color.bmp"</span>;</span><br><span class="line">	salt(load_path, save_path_color_salt, <span class="number">0.15</span>);</span><br><span class="line">	pepper(load_path, save_path_color_pepper, <span class="number">0.15</span>);</span><br><span class="line">	peppersalt(load_path, save_path_color_peppersalt, <span class="number">0.15</span>);</span><br><span class="line">	addgaussiannoise(load_path, save_path_color_gaussiannoise, <span class="number">1.0</span>, <span class="number">20</span>, <span class="number">32</span>);</span><br><span class="line">	<span class="comment">//arithmetic_mean_filter(save_path_color_salt, 5, save_path_arithmetic_mean_filter_salt_color);</span></span><br><span class="line">	<span class="comment">//arithmetic_mean_filter(save_path_color_pepper, 5, save_path_arithmetic_mean_filter_pepper_color);</span></span><br><span class="line">	<span class="comment">//arithmetic_mean_filter(save_path_color_peppersalt, 5, save_path_arithmetic_mean_filter_peppersalt_color);</span></span><br><span class="line">	<span class="comment">//arithmetic_mean_filter(save_path_color_gaussiannoise, 5, save_path_arithmetic_mean_filter_gaussiannoise_color);</span></span><br><span class="line">	<span class="built_in">string</span> save_path_geometric_mean_filter_salt_color = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_geometric_mean_filter_salt_color.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_geometric_mean_filter_pepper_color = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_geometric_mean_filter_pepper_color.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_geometric_mean_filter_peppersalt_color = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_geometric_mean_filter_peppersalt_color.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_geometric_mean_filter_gaussiannoise_color = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/4/save/lenna_geometric_mean_filter_gaussiannoise_color.bmp"</span>;</span><br><span class="line">	<span class="comment">//geometric_mean_filter(save_path_color_salt, 5, save_path_geometric_mean_filter_salt_color);</span></span><br><span class="line">	<span class="comment">//geometric_mean_filter(save_path_color_pepper, 5, save_path_geometric_mean_filter_pepper_color);</span></span><br><span class="line">	<span class="comment">//geometric_mean_filter(save_path_color_peppersalt, 5, save_path_geometric_mean_filter_peppersalt_color);</span></span><br><span class="line">	<span class="comment">//geometric_mean_filter(save_path_color_gaussiannoise, 5, save_path_geometric_mean_filter_gaussiannoise_color);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实验五：频域滤波"><a href="#实验五：频域滤波" class="headerlink" title="实验五：频域滤波"></a>实验五：频域滤波</h1><h2 id="实验五内容"><a href="#实验五内容" class="headerlink" title="实验五内容"></a>实验五内容</h2><p>1、 灰度图像的DFT和IDFT<br>具体内容：利用OpenCV提供的cvDFT函数对图像进行DFT和IDFT变换。<br>2、利用理想高通和低通滤波器对灰度图像进行频域滤波<br>具体内容：利用cvDFT函数实现DFT，在频域上利用理想高通和低通滤波器进行滤波，并把滤波过后的图像显示在屏幕上（观察振铃现象），要求截止频率可输入。<br>3、利用布特沃斯高通和低通滤波器对灰度图像进行频域滤波<br>具体内容：利用cvDFT函数实现DFT ，在频域上进行利用布特沃斯高通和低通滤波器进行滤波，并把滤波过后的图像显示在屏幕上（观察振铃现象），要求截止频率和n可输入。</p>
<h2 id="实验五理论知识"><a href="#实验五理论知识" class="headerlink" title="实验五理论知识"></a>实验五理论知识</h2><h3 id="二维离散傅里叶变换（DFT）与逆变换（IDFT）"><a href="#二维离散傅里叶变换（DFT）与逆变换（IDFT）" class="headerlink" title="二维离散傅里叶变换（DFT）与逆变换（IDFT）"></a>二维离散傅里叶变换（DFT）与逆变换（IDFT）</h3><p><strong>二维DFT公式:</strong><br>$$<br>F(u, v)=\sum_{x=0}^{M-1} \sum_{y=0}^{N-1} f(x, y) e^{-j 2 \pi\left(\frac{\mathrm{ux}}{\mathrm{M}}+\frac{v y}{N}\right)}<br>$$<br><strong>二维IDFT公式:</strong><br>$$<br>f(x, y)=\frac{1}{M N} \sum_{u=0}^{M-1} \sum_{v=0}^{N-1} F(u, v) e^{j 2 \pi\left(\frac{\operatorname{ux}}{M}+\frac{v y}{N}\right)}<br>$$<br>注意上面两个公式来自数字图像处理（第三版）这本书，网上有不少博客把这两个公式写反了。<br>其中（x，y）为时域图上坐标（即图像上像素点坐标），f（x,y）为（x，y）处的灰度值，（u，v）为频域图上坐标，F（u，v）为（u，v）处的幅值。M和N分别为图像长和宽上像素点个数。j是虚数。<br><strong>二维DFT变换可分离为两次一维DFT变换，这是由二维DFT变换的可分离性决定的:</strong><br>$$<br>F(u,v)=\sum_{x=0}^{M-1}\left[\sum_{y=0}^{N-1} f(x,y) e^{-j 2 \pi vy / N}\right] e^{-j 2 \pi ux/ M}<br>$$<br>先对行（y变量）做变换:<br>$$<br>F(x, v)= \sum_{y=0}^{N-1} f(x, y) e^{-j 2 \pi u x / N}<br>$$<br>然后对列（x变量）进行变换:<br>$$<br>F(u, v)= \sum_{x=0}^{M-1} F(x, v) e^{-j 2 \pi ux / M}<br>$$<br><strong>同理，二维IDFT变换也可分离为两次一维IDFT变换:</strong><br>$$<br>f(x,y)=\frac{1}{M N} \sum_{u=0}^{M-1}\left[\sum_{v=0}^{N-1} F(u,v) e^{j 2 \pi vy / N}\right] e^{j 2 \pi ux / M}<br>$$</p>
<h3 id="一维离散傅里叶变换（DFT）与逆变换（IDFT）"><a href="#一维离散傅里叶变换（DFT）与逆变换（IDFT）" class="headerlink" title="一维离散傅里叶变换（DFT）与逆变换（IDFT）"></a>一维离散傅里叶变换（DFT）与逆变换（IDFT）</h3><p>DFT和IDFT既可以指一维的离散傅里叶变换和逆变换，也可以指二维的离散傅里叶变换和逆变换。<br><strong>一维DFT公式:</strong><br>$$<br>F(u)= \sum_{n=0}^{N-1} f(n) e^{-j 2 \pi u n / N}<br>$$<br><strong>一维IDFT公式:</strong><br>$$<br>f(n)=\frac{1}{N} \sum_{n=0}^{N-1} F(u) e^{j 2 \pi u n / N}<br>$$<br>其中f(n)是一维的时间序列信号，长度为N，u为频率，F（u）为频率u对应的幅值。<br>注意上面两个公式来自数字图像处理（第三版）这本书，网上有不少博客把这两个公式写反了。<br>j是一个虚数单位:<br>$$<br>j^{2}=-1<br>$$<br>一个复数z可以表示为z=a+bi（a,b∈R），其中a为实部，b为虚部，i为虚数单位。<br><strong>欧拉公式:</strong><br>$$<br>e^{j \theta}=\cos \theta+j \sin \theta<br>$$<br>$$<br>e^{-j \theta}=\cos \theta-j \sin \theta<br>$$<br><strong>由上面欧拉公式，一维DFT公式可写为:</strong><br>$$<br>F(u)=\sum_{n=0}^{N-1} f(n)\left(\cos \frac{2 \pi u n}{N}-j \sin \frac{2 \pi u n}{N}\right)<br>$$</p>
<h3 id="快速一维傅里叶变换（FFT）"><a href="#快速一维傅里叶变换（FFT）" class="headerlink" title="快速一维傅里叶变换（FFT）"></a>快速一维傅里叶变换（FFT）</h3><p><strong>一维DFT公式为:</strong><br>$$<br>F(u)= \sum_{n=0}^{N-1} f(n) e^{-j 2 \pi u n / N}<br>$$<br>注意从这里开始所有的N都默认为2的整数次幂。可以看出，上面的公式时间复杂度为<br>$$<br>O\left(n^{2}\right)<br>$$<br>当N较大时，这个计算量是很大的。<br>令<br>$$<br>W_{N}=e^{-j \frac{2 \pi}{N}}<br>$$<br><strong>则一维DFT公式写为:</strong><br>$$<br>F(u)=\sum_{n=0}^{N-1} f(n) W_{N}^{n u}<br>$$<br><strong>一维傅里叶变换的周期性:</strong><br>离散傅里叶变换DFT和它的里变换都以傅里叶变换的点数N为周期的。即:<br>$$<br>F(u)=F(u \pm k N)<br>$$<br>我们很容易证明下列结论:<br>$$<br>W_{N}^{n u}=W_{N}^{(n+r N) u}=W_{N}^{(u+r N) n} ,\text{r为整数}<br>$$<br>$$<br>W_{N}^{n u}=W_{m N}^{m n u}, W_{N}^{n u}=W_{N / m}^{n u / m}<br>$$<br>我们还可以求出一些特殊值:<br>$$<br>W_{N}^{N / 2}=-1<br>$$<br>$$<br>W_{N}^{k+\frac{N}{2}}=-W_{N}^{k}<br>$$<br>$$<br>W_{N}^{(N-k) n}=W_{N}^{(N-n) k}=W_{N}^{-n k}<br>$$<br>假设N是2的整数次幂，FFT的思想是每次都把序列分为奇序列与偶序列。x1(n)和x2(n)的长度都是N/2，x1(n)是偶数序列，x2(n)是奇数序列，<br>$$<br>\begin{cases}{x(2 r)=x_{1}(r)} \\ {x(2 r+1)=x_{2}(r)}\end{cases}<br>$$<br>$$<br>r=0,1, \ldots, \frac{N}{2}-1<br>$$<br>那么原序列可以表示为奇序列与偶序列之和:<br>$$<br>x(n)=x_{1}(r)+x_{2}(r)<br>$$<br>则有:<br>$$<br>F(u)=\sum_{n=0(n为偶数)}^{N-1} x(2r) W_{N}^{2 n u}+\sum_{n=0(n为奇数)}^{N-1} x(2r+1) W_{N}^{(2 n+1) u}<br>$$<br>$$<br>F(u)=\sum_{r=0}^{\frac{N}{2}-1} x_{1}(r) W_{N}^{2 r u}+\sum_{r=0}^{\frac{N}{2}-1} x_{2}(r) W_{N}^{(2 r+1) u}<br>$$<br>由上面周期性推导出的几个公式，可得:<br>$$<br>F(u)=\sum_{r=0}^{\frac{N}{2}-1} x_{1}(r) W_{N / 2}^{r u}+W_{N}^{u} \sum_{r=0}^{\frac{N}{2}-1} x_{2}(r) W_{N / 2}^{r u}<br>$$<br>令<br>$$<br>F_{1}(u)=\sum_{r=0}^{\frac{N}{2}-1} x_{1}(r) W_{N / 2}^{r u}<br>$$<br>$$<br>F_{2}(u)=\sum_{r=0}^{\frac{N}{2}-1} x_{2}(r) W_{N / 2}^{r u}<br>$$<br>则<br>$$<br>F(u)=F_{1}(u)+W_{N}^{u} F_{2}(u)<br>$$<br>其中<br>$$<br>r=0,1, \ldots, \frac{N}{2}-1，u=0,1, \ldots, \frac{N}{2}-1<br>$$<br>F1（u），F2（u）分别是x1（r）和x2（r）的N/2点DFT。这样我们就可以把一个N点DFT分解为两个N/2点DFT，并通过上式组合成N点DFT。式中的r:<br>$$<br>r=0,1, \ldots, \frac{N}{2}-1，u=0,1, \ldots, \frac{N}{2}-1<br>$$<br>也就是说，这只是F（u）的前一半序列。我们可以应用周期性求解F（u）的后一半序列。由前面周期性推导的几个公式，可以很容易地证明:<br>$$<br>X_{1}\left(\frac{N}{2}+k\right)=X_{1}(k)<br>$$<br>$$<br>X_{2}\left(\frac{N}{2}+k\right)=X_{2}(k)<br>$$<br>$$<br>W_{N}^{k+\frac{N}{2}}=-W_{N}^{k}<br>$$<br>于是有<br>$$<br>F\left(u+\frac{N}{2}\right)=X_{1}(u)-W_{N}^{u} X_{2}(u), k=0,1, \ldots, \frac{N}{2}-1<br>$$<br>这样我们就通过两个N/2点DFT序列组合出一个完整的N点DFT序列。<br>利用FFT求解DFT时， 复数乘法N2log2N次，复数加法Nlog2N次，故总时间复杂度为:<br>$$<br>O\left(nlog_{2}n\right)<br>$$</p>
<h3 id="一维傅里叶变换（DFT-与逆变换（IDFT）计算实例"><a href="#一维傅里叶变换（DFT-与逆变换（IDFT）计算实例" class="headerlink" title="一维傅里叶变换（DFT)与逆变换（IDFT）计算实例"></a>一维傅里叶变换（DFT)与逆变换（IDFT）计算实例</h3><p>令<br>$$<br>W_{N}=e^{-j \frac{2 \pi}{N}}<br>$$<br><strong>则一维DFT公式写为:</strong><br>$$<br>F(u)=\sum_{n=0}^{N-1} f(n) W_{N}^{n u}<br>$$<br><strong>假设有一个序列长度N=4，具体的序列x（n）=1，2，-1，3，n=0，1，2，3。</strong><br>由N=4，得:<br>$$<br>W=e^{-j \frac{2 \pi}{4}}=\cos \left(\frac{\pi}{2}\right)-j \sin \left(\frac{\pi}{2}\right)=-j<br>$$<br>于是有:<br>$$<br>\left[ \begin{array}{c}{F(0)} \\ {F(1)} \\ {F(2)} \\ {F(3)}\end{array}\right]=\left[ \begin{array}{cccc}{W^{0}} &amp; {W^{0}} &amp; {W^{0}} &amp; {W^{0}} \\ {W^{0}} &amp; {W^{1}} &amp; {W^{2}} &amp; {W^{3}} \\ {W^{0}} &amp; {W^{2}} &amp; {W^{4}} &amp; {W^{6}} \\ {W^{0}} &amp; {W^{3}} &amp; {W^{6}} &amp; {W^{9}}\end{array}\right] \left[ \begin{array}{c}{f(0)} \\ {f(1)} \\ {f(2)} \\ {f(3)}\end{array}\right]<br>$$<br>$$<br>=\left[ \begin{array}{cccc}{1} &amp; {1} &amp; {1} &amp; {1} \\ {1} &amp; {-j} &amp; {-1} &amp; {j} \\ {1} &amp; {-1} &amp; {1} &amp; {-1} \\ {1} &amp; {j} &amp; {-1} &amp; {-j}\end{array}\right] \left[ \begin{array}{c}{1} \\ {2} \\ {-1} \\ {3}\end{array}\right]=\left[ \begin{array}{c}{5} \\ {2+j} \\ {-5} \\ {2-j}\end{array}\right]<br>$$<br>逆变换则为:<br>$$<br>f(n)=\frac{1}{4} \left[ \begin{array}{cccc}{W^{0}} &amp; {W^{0}} &amp; {W^{0}} &amp; {W^{0}} \\ {W^{0}} &amp; {W^{-1}} &amp; {W^{-2}} &amp; {W^{-3}} \\ {W^{0}} &amp; {W^{-2}} &amp; {W^{-4}} &amp; {W^{-6}} \\ {W^{0}} &amp; {W^{-3}} &amp; {W^{-6}} &amp; {W^{-9}}\end{array}\right] \left[ \begin{array}{c}{5} \\ {2+j} \\ {-5} \\ {2-j}\end{array}\right]<br>$$<br>$$<br>=\frac{1}{4} \left[ \begin{array}{cccc}{1} &amp; {1} &amp; {1} &amp; {1} \\ {1} &amp; {j} &amp; {-1} &amp; {-j} \\ {1} &amp; {-1} &amp; {1} &amp; {-1} \\ {1} &amp; {1} &amp; {-j} &amp; {j}\end{array}\right] \left[ \begin{array}{c}{5} \\ {2+j} \\ {-5} \\ {2-j}\end{array}\right]=\left[ \begin{array}{c}{1} \\ {2} \\ {-1} \\ {3}\end{array}\right]<br>$$</p>
<h3 id="对一维傅里叶变换的含义解释"><a href="#对一维傅里叶变换的含义解释" class="headerlink" title="对一维傅里叶变换的含义解释"></a>对一维傅里叶变换的含义解释</h3><p><strong>一维傅里叶变换就是将一个一维的时间序列信号分解成成无数个同时间序列的x同向、频率u不同的三角函数（即一维正交基），原信号f（x）可视作是e的复指数F（u）乘积的线性组合。</strong><br>对于频谱图上的每一个频率值u都对应一个三角函数。每一个频率值u对应一个F（u）。F（u）是一个复数a+bi的形式，这个复数的模就是频率为u的三角函数的幅值（三角函数的最大/最小值），复数的角度arctan（b/a）就是三角函数的相位（相位应该在0到2pai之间）。<br>想象一下，现在我们输入一连串的时间序列f（x），其下标即时间点x，每个时间点x的值为f（x），以x为x轴，f（x）为y轴画一个直角坐标系图。我们的频谱图的频率长度和时间序列长度一样，但其x轴的含义是频率u。每一个频率u都可以确定一个三角函数，这个三角函数也可以画在时间序列的x和y轴上，三角函数的x轴也是时间点，其y值由两个方面确定：F（u）是一个复数a+bi，这个复数的模确定三角函数的幅值，同时arctan（b/a）就是三角函数的相位（相位应该在0到2pai之间）。频谱图上每一个u对应的三角函数以e的复指数与F（u）乘积的线性组合的形式叠加起来，就是我们的时间序列f（x）。</p>
<h3 id="对二维傅里叶变换的含义解释"><a href="#对二维傅里叶变换的含义解释" class="headerlink" title="对二维傅里叶变换的含义解释"></a>对二维傅里叶变换的含义解释</h3><p><strong>二维傅里叶变换就是将一个二维的时间序列信号（时间点为（x，y））分解成无数个三角平面波之和。一个三角平面波也可以看成由两个三角函数所构成的乘积，因此我们也可以说一个二维时间序列信号可以表示为无数个x向正余弦函数与y向正余弦函数乘积（即二维正交基）的线性组合。</strong><br>三角平面波就是一个在二维直角坐标系（x，y）的三角函数向z轴方向伸展的结果。确定一个三角平面波需要四个参数，除了频率，幅度，相位之外，此外还有一个方向参数。我们使用一个二维的频域图（u，v，F（u，v））来保存二维傅里叶变换的结果。频域图上的点（u，v） 就代表这个点上的频率对应的三角平面波的法向量n，这个法向量的模代表这个平面波的频率，这个点里面保存的F（u，v）复数a+bi的模就是三角平面波的幅度，arctan（b/a）就是三角平面波的相位。<br>在一维FT变换后，频域呈现对称性，即前半段代表（0，fs/2）频率，而后半段代表（-fs/2，0）频率。在二维中的u和v也是如此。因此为了方便，一般会将图像1和4象限、2和3象限进行互换，这样就将0频率移动到了频域图中心。<br>对于互换后的频域图，中心的低频（图像上亮白部分）贡献了图像的主体，周围高频（黑色部分）提供图像的细节和边缘。</p>
<h3 id="小波变换"><a href="#小波变换" class="headerlink" title="小波变换"></a>小波变换</h3><p>傅里叶变换只能获取一段时间的信号总体上包含哪些频率的成分，但是对各成分出现的时刻不知道。两段完全不相同的不规律信号可能经过傅里叶变换后会有相同的频谱图。所以，对于不规律信号，傅里叶变换有很大局限性。<br>对于不规律信号，只知道包含哪些频率成分是不够的，我们还想知道各个频率成分出现的时间、频率随时间变化的情况，各个时刻的瞬时频率及其幅值，这就是时频分析。小波变换得到的正是一段时间信号的时频图。<br>傅里叶变换把无限长的三角函数作为基函数，而小波变换使用有限长的会衰减的小波作为基函数，这个小波只在一小段时间内有突变值，其余时间都为0值。<br>傅里叶变换变量只有频率ω，小波变换有两个变量：尺度a（scale）和平移量τ（translation）。尺度a控制小波函数的伸缩，平移量τ控制小波函数的平移。尺度就对应于频率（反比），平移量τ就对应于时间。<br>每个小波变换都会有一个mother wavelet，我们称之为母小波，同时还有一个scaling function，中文是尺度函数，也被成为父小波。任何小波变换的basis函数，其实就是对这个母小波和父小波缩放和平移后的集合。<br>当伸缩、平移到时间信号与某个频率的小波突变处重合时，会相乘得到一个大的值。这样我们就可以不仅可以知道频率，还知道该频率在时域上的具体时间点。</p>
<h3 id="理想低通滤波"><a href="#理想低通滤波" class="headerlink" title="理想低通滤波"></a>理想低通滤波</h3><p>理想低通滤波器在以频域图上以中心点（p，q）为圆心、D0（又叫截止频率）为半径的圆内，通过所有的频率，而在圆外截断所有的频率。即:<br>$$<br>D(u, v)=\sqrt{\left(u-\frac{p}{2}\right)^{2}+\left(v-\frac{q}{2}\right)^{2}}<br>$$<br>D（u, v）表示频域图上某个点（u，v）距离频域图圆心（p，q）的距离。<br>$$<br>H(u, v)=\begin{cases}{1, D(u, v) \leq D_{0}} \\ {0, D(u, v)&gt;D_{0}}\end{cases}<br>$$<br>D0为截止频率。即先做傅里叶变换得到频域图，频域图上每个点的F（u，v）乘以对应的H（u，v）后得到新的F（u，v）。然后再做逆傅里叶变换得到原图像。理想低通滤波器可以达到模糊/平滑图像的效果。<br><strong>振铃现象:</strong><br>由于理想低通滤波在频域图的圆内外边缘的F（u，v）急剧变化，其高频信息全部丢失（图像的细节和边缘丢失），这样做逆傅里叶变换得到的图像就会产生振铃现象，即图像的灰度剧烈变化处产生的震荡，就好像钟被敲击后产生的空气震荡。</p>
<h3 id="理想高通滤波"><a href="#理想高通滤波" class="headerlink" title="理想高通滤波"></a>理想高通滤波</h3><p>理想高通滤波器与理想低通滤波器正好相反，其在以频域图上以中心点（p，q）为圆心、D0（又叫截止频率）为半径的圆内，截断所有的频率，而在圆外通过所有的频率。即:<br>$$<br>D(u, v)=\sqrt{\left(u-\frac{p}{2}\right)^{2}+\left(v-\frac{q}{2}\right)^{2}}<br>$$<br>D（u, v）表示频域图上某个点（u，v）距离频域图圆心（p，q）的距离。<br>$$<br>H(u, v)=\begin{cases}{0, D(u, v) \leq D_{0}} \\ {1, D(u, v)&gt;D_{0}}\end{cases}<br>$$<br>D0为截止频率。即先做傅里叶变换得到频域图，频域图上每个点的F（u，v）乘以对应的H（u，v）后得到新的F（u，v）。然后再做逆傅里叶变换得到原图像。理想高通滤波器可以提取物体边缘。</p>
<h3 id="Butterworth低通滤波"><a href="#Butterworth低通滤波" class="headerlink" title="Butterworth低通滤波"></a>Butterworth低通滤波</h3><p>$$<br>H(u, v)=\frac{1}{1+\left(\frac{D(u, v)}{D_{0}}\right)^{2 n}}<br>$$<br>其中n称为阶数。D0为截止频率。1阶Butterworth低通滤波没有出现振铃现象，随着阶数增大，振铃现象越来越明显。<br>先做傅里叶变换得到频域图，频域图上每个点的F（u，v）乘以对应的H（u，v）后得到新的F（u，v）。然后再做逆傅里叶变换得到原图像。Butterworth低通滤波是对理想低通滤波的改进。</p>
<h3 id="Butterworth高通滤波"><a href="#Butterworth高通滤波" class="headerlink" title="Butterworth高通滤波"></a>Butterworth高通滤波</h3><p>$$<br>H(u, v)=\frac{1}{1+\left(\frac{D_{0}}{D(u, v)}\right)^{2 n}}<br>$$<br>其中n称为阶数。D0为截止频率。先做傅里叶变换得到频域图，频域图上每个点的F（u，v）乘以对应的H（u，v）后得到新的F（u，v）。然后再做逆傅里叶变换得到原图像。Butterworth高通滤波是对理想高通滤波的改进。</p>
<h2 id="实验五代码"><a href="#实验五代码" class="headerlink" title="实验五代码"></a>实验五代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pch.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt; //包含imread, imshow等</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt; //包含cvtColor等</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gray_image</span><span class="params">(<span class="built_in">string</span> load_path, <span class="built_in">string</span> save_path_gray_image)</span> </span>&#123;</span><br><span class="line">	Mat graypScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span></span><br><span class="line">	graypScr = imread(load_path, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//imshow("gray_picture", graypScr);</span></span><br><span class="line">	<span class="comment">//waitKey(0);</span></span><br><span class="line">	<span class="comment">//destroyAllWindows();</span></span><br><span class="line">	imwrite(save_path_gray_image, graypScr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// F(u,v)即求频域函数,u,v代表空间频率，即像素值在x方向和y方向上的梯度,图像尺寸为M×N,傅里叶变换是从时域变换到频域</span></span><br><span class="line"><span class="comment">// 对于图像,其中物体的边界处频率较高,因为差异大</span></span><br><span class="line"><span class="comment">// 频谱图中图像最明亮的像素放到中央,然后逐渐变暗,在边缘上的像素最暗,这样可以发现图像中亮、暗像素的百分比，即为频域中的振幅A的强度</span></span><br><span class="line"><span class="comment">// 对二维傅里叶变换公式,t=(ux/m+vy/n),F(u,v)=f(x,y)exp(2*pi*t),x从0到m,y从0到n遍历</span></span><br><span class="line"><span class="comment">// 两个求和号对图像进行遍历,f(x,y)取出原像素的数值,当x=0,(横轴不动),对y进行遍历时</span></span><br><span class="line"><span class="comment">// t的后一项表示变换前像素的位置比例与变换后的位置相乘,映射到新的位置,且能够反映像素延y方向距离的差异,越靠后的像素(y越大)t值越大,即t能够反映出不同位置(纵轴)像素之间的差异,前一项含义为保留像素相对位置(横轴)的信息(遍历y时为常数),2π为修正参数</span></span><br><span class="line"><span class="comment">// f(x,y)代表当前像素点(x,y)像素值</span></span><br><span class="line"><span class="comment">// 在图像处理领域,通过DFT可以将图像转换到频域,实现高通和低通滤波,频域相当于是图像的特征</span></span><br><span class="line"><span class="comment">// 频谱图中心看到更多的白色区域,表示低振幅的波占到了多数,高振幅的波占少数,而且说明了波的整体频率偏低</span></span><br><span class="line"><span class="comment">// 傅立叶频域图上我们看到的明暗不一的亮点,实际上是图像上某一点与邻域点差异的强弱,即梯度的大小,也即该点的频率的大小</span></span><br><span class="line"><span class="comment">// 可以这么理解,图像中的低频部分指低梯度的点，高频部分相反</span></span><br><span class="line"><span class="comment">// 梯度大则该点的亮度强,否则该点亮度弱。这样通过观察傅立叶变换后的频域图，也叫功率图</span></span><br><span class="line"><span class="comment">// 如果频域图中暗的点数更多,那么实际图像是比较柔和的(因为各点与邻域差异都不大，梯度相对较小)</span></span><br><span class="line"><span class="comment">// 如果频谱图中亮的点数多,那么实际图像一定是尖锐的,边界分明且边界两边像素差异较大的</span></span><br><span class="line"><span class="comment">// 频域变换的用途:压缩和去噪</span></span><br><span class="line"><span class="comment">// 压缩的原理就是在频域中,大部分频域的值为0(或接近0,可以进行有损压缩,如jpeg图像),只要压缩频域中的少数非0值即可达到图片压缩的目的</span></span><br><span class="line"><span class="comment">// 去噪则是通过频域的滤波实现,因为噪声大部分情况下体现为高频信号,使用低通滤波器即可滤除高频噪声(当然,也会带来损失,那就是边缘会变得模糊,边缘也是高频信号)</span></span><br><span class="line"><span class="comment">// 二维的傅里叶变换(DFT)实际上是计算两次一维的FFT变换实现的,根据FFT变换的计算要求,需要图像的行数、列数均满足2的n次方,如果不满足,在计算FFT之前先要对图像补零以满足2的n次</span></span><br><span class="line"><span class="comment">// FFT是离散傅氏变换的快速算法,即为快速傅氏变换,FFT其实是一个用O(nlog⁡2n)的时间将一个用系数表示的多项式转换成它的点值表示的算法</span></span><br><span class="line"><span class="comment">// n次多项式的系数为f(x)=&#123;a0,a1,...,an-1&#125;,这样表示出来的多项式称为系数表示法</span></span><br><span class="line"><span class="comment">// 点值表示法即把n个不同的(x,y)点代入，把n条式子联立起来成为一个有n条方程的n元方程组，每一项的系数都可以解出来,这n个点唯一确定该多项式</span></span><br><span class="line"><span class="comment">// 多项式可用f(x)=&#123;(x0,y0),(x1,y1),...,(xn-1,yn-1)&#125;表示,这就是点值表示法</span></span><br><span class="line"><span class="comment">// 系数表示法做多项式乘法时间复杂度O(n2),但两个用点值表示的多项式相乘，只需要O(n)的时间</span></span><br><span class="line"><span class="comment">// 设两个多项式为f(x)=&#123;(x0,f0),(x1,f1),...,(xn-1,fn-1)&#125;和g(x)=&#123;(x0,g0),(x1,g1),...,(xn-1,gn-1)&#125;</span></span><br><span class="line"><span class="comment">// 乘积h(x)=&#123;(x0,f0*g0),(x1,f1*g1),...,(xn-1,fn-1*gn-1)&#125;</span></span><br><span class="line"><span class="comment">// FFT变换:设一个多项式A(x),按A(x)下标的奇偶性把A(x)分成两半，右边再提一个x,即左右分别设为A1(x)和A2(x),A(x)=A1(x2)+xA2(x2),然后可以用分治法来作</span></span><br><span class="line"><span class="comment">// 设一个序列为1,2,-1,3,N=4,若W=exp(-j*(2*pi/4),欧拉公式exp(-it)=cos(t)-i*sin(t),exp(it)=cos(t)+i*sin(t),故W=cos(pi/2)-j*sin(pi/2)=-j</span></span><br><span class="line"><span class="comment">// 一维DFT变换公式X(k)=x(n)W的n*k次方(W即上面计算出的-j),n从0到n-1求和;逆变换x(n)=X(k)W的-n*k次方(w=-j),n从0到n-1求和后乘以1/N,原始计算为exp(j*2*pi/N)</span></span><br><span class="line"><span class="comment">// 如X(0)=x(0)*W的0*0次方+x(1)*W的1*0次方+...+x(3)*W的3*0次方,X(3)=x(0)*W的0*3次方+...+x(3)*W的3*3次方,W=-j,W的0次方为1,W的平方为-1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFT</span><span class="params">(<span class="built_in">string</span> load_path, <span class="built_in">string</span> save_path_DFT)</span> </span>&#123;</span><br><span class="line">	Mat pScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回,注意这里得到的pScr必须为灰度图格式,否则后面会报错,原因是如果读入RGB图像,padded也是三通道的RGB格式,那么Mat planes[]就会报错</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> row = pScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = pScr.cols;</span><br><span class="line">	<span class="keyword">int</span> channel = pScr.channels();</span><br><span class="line">	<span class="comment">//以0填充输入图像矩阵</span></span><br><span class="line">	Mat padded;</span><br><span class="line">	<span class="keyword">int</span> m = getOptimalDFTSize(pScr.rows);</span><br><span class="line">	<span class="keyword">int</span> n = getOptimalDFTSize(pScr.cols);</span><br><span class="line">	<span class="comment">//扩充原图的边缘,将图像变大,然后以各种外插方式自动填充图像边界,比如均值滤波或者中值滤波中,使用copyMakeBorder将原图稍微放大,然后我们就可以处理边界的情况</span></span><br><span class="line">	<span class="comment">//填充输入图像I，输入矩阵为padded,上方和左方不做填充处理,padded与pScr的差集部分填充为0,其他部分同pScr,padded为我们的目标图像</span></span><br><span class="line">	copyMakeBorder(pScr, padded, <span class="number">0</span>, m - pScr.rows, <span class="number">0</span>, n - pScr.cols, BORDER_CONSTANT, Scalar::all(<span class="number">0</span>));</span><br><span class="line">	<span class="comment">// CV_32S等同于CV_32SC1,是单通道的,CV_32F取值范围为0-1.0，imshow的时候会把图像乘以255后再显示</span></span><br><span class="line">	Mat planes[] = &#123; Mat_&lt;<span class="keyword">float</span>&gt;(padded), Mat::zeros(padded.size(),CV_32F) &#125;;</span><br><span class="line">	Mat complexI;</span><br><span class="line">	<span class="comment">// 将planes融合合并成一个多通道数组complexI,2是需要合并的矩阵的个数</span></span><br><span class="line">	merge(planes, <span class="number">2</span>, complexI);</span><br><span class="line">	<span class="comment">//进行傅里叶变换</span></span><br><span class="line">	dft(complexI, complexI);</span><br><span class="line">	<span class="comment">//计算幅值,转换到对数尺度(logarithmic scale)</span></span><br><span class="line">	<span class="comment">//=&gt; log(1 + sqrt(Re(DFT(I))^2 + Im(DFT(I))^2))</span></span><br><span class="line">	<span class="comment">// planes[0] = Re(DFT(I),planes[1] = Im(DFT(I)),即planes[0]为实部,planes[1]为虚部</span></span><br><span class="line">	<span class="comment">// 振幅和相位可以用实部和虚部表示出来</span></span><br><span class="line">	split(complexI, planes);</span><br><span class="line">	<span class="comment">// 计算二维矢量的幅值,第一个参数表示矢量的浮点型X坐标值,也就是实部;第二个参数表示矢量的浮点型Y坐标值,也就是虚部;第三个参数是输出的幅值</span></span><br><span class="line">	magnitude(planes[<span class="number">0</span>], planes[<span class="number">1</span>], planes[<span class="number">0</span>]);</span><br><span class="line">	Mat magI = planes[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">// 幅值都加上1再转换成对数尺度</span></span><br><span class="line">	magI += Scalar::all(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">log</span>(magI, magI);</span><br><span class="line">	<span class="comment">//如果有奇数行或列，则对频谱进行裁剪</span></span><br><span class="line">	magI = magI(Rect(<span class="number">0</span>, <span class="number">0</span>, magI.cols&amp;<span class="number">-2</span>, magI.rows&amp;<span class="number">-2</span>));</span><br><span class="line">	<span class="comment">//重新排列傅里叶图像中的象限，使得原点位于图像中心</span></span><br><span class="line">	<span class="keyword">int</span> cx = magI.cols / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> cy = magI.rows / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">// 根据中心点划定象限</span></span><br><span class="line">	<span class="function">Mat <span class="title">q0</span><span class="params">(magI, Rect(<span class="number">0</span>, <span class="number">0</span>, cx, cy))</span></span>;       <span class="comment">//左上角图像划定ROI区域</span></span><br><span class="line">	<span class="function">Mat <span class="title">q1</span><span class="params">(magI, Rect(cx, <span class="number">0</span>, cx, cy))</span></span>;      <span class="comment">//右上角图像</span></span><br><span class="line">	<span class="function">Mat <span class="title">q2</span><span class="params">(magI, Rect(<span class="number">0</span>, cy, cx, cy))</span></span>;      <span class="comment">//左下角图像</span></span><br><span class="line">	<span class="function">Mat <span class="title">q3</span><span class="params">(magI, Rect(cx, cy, cx, cy))</span></span>;     <span class="comment">//右下角图像</span></span><br><span class="line">	<span class="comment">//变换左上角和右下角象限,即交换q0和q3的幅值</span></span><br><span class="line">	Mat tmp;</span><br><span class="line">	q0.copyTo(tmp);</span><br><span class="line">	q3.copyTo(q0);</span><br><span class="line">	tmp.copyTo(q3);</span><br><span class="line">	<span class="comment">//变换右上角和左下角象限,即交换q1和q2的幅值</span></span><br><span class="line">	q1.copyTo(tmp);</span><br><span class="line">	q2.copyTo(q1);</span><br><span class="line">	tmp.copyTo(q2);</span><br><span class="line">	<span class="comment">// 最后频谱图应当归一化到0-1</span></span><br><span class="line">	normalize(magI, magI, <span class="number">0</span>, <span class="number">1</span>, CV_MINMAX);</span><br><span class="line">	<span class="comment">//imshow("magnitude", magI);</span></span><br><span class="line">	<span class="comment">//waitKey(0);</span></span><br><span class="line">	<span class="comment">//destroyAllWindows();</span></span><br><span class="line">	normalize(magI, magI, <span class="number">0</span>, <span class="number">255</span>, CV_MINMAX);</span><br><span class="line">	imwrite(save_path_DFT, magI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 傅里叶变换后再逆变换得到原图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFT_IDFT</span><span class="params">(<span class="built_in">string</span> load_path, <span class="built_in">string</span> save_path_DFT_IDFT_1, <span class="built_in">string</span> save_path_DFT_IDFT_2)</span> </span>&#123;</span><br><span class="line">	Mat pScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回,注意这里得到的pScr必须为灰度图格式,否则后面会报错,原因是如果读入RGB图像,padded也是三通道的RGB格式,那么Mat planes[]就会报错</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> row = pScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = pScr.cols;</span><br><span class="line">	<span class="keyword">int</span> channel = pScr.channels();</span><br><span class="line">	<span class="comment">//以0填充输入图像矩阵</span></span><br><span class="line">	Mat padded;</span><br><span class="line">	<span class="keyword">int</span> m = getOptimalDFTSize(pScr.cols);</span><br><span class="line">	<span class="keyword">int</span> n = getOptimalDFTSize(pScr.rows);<span class="comment">//获取最佳尺寸，快速傅立叶变换要求尺寸为2的n次方</span></span><br><span class="line">	<span class="comment">//扩充原图的边缘,将图像变大,然后以各种外插方式自动填充图像边界,比如均值滤波或者中值滤波中,使用copyMakeBorder将原图稍微放大,然后我们就可以处理边界的情况</span></span><br><span class="line">	<span class="comment">//填充输入图像I，输入矩阵为padded,上方和左方不做填充处理,padded与pScr的差集部分填充为0,其他部分同pScr,padded为我们的目标图像</span></span><br><span class="line">	copyMakeBorder(pScr, padded, <span class="number">0</span>, n - pScr.rows, <span class="number">0</span>, m - pScr.cols, BORDER_CONSTANT, Scalar::all(<span class="number">0</span>));</span><br><span class="line">	<span class="comment">// CV_32S等同于CV_32SC1,是单通道的,CV_32F取值范围为0-1.0，imshow的时候会把图像乘以255后再显示</span></span><br><span class="line">	Mat planes[] = &#123; Mat_&lt;<span class="keyword">float</span>&gt;(padded),Mat::zeros(padded.size(),CV_32F) &#125;;</span><br><span class="line">	Mat complexIm;</span><br><span class="line">	<span class="comment">// 将planes融合合并成一个多通道数组complexI,2是需要合并的矩阵的个数</span></span><br><span class="line">	merge(planes, <span class="number">2</span>, complexIm);</span><br><span class="line">	<span class="comment">//进行傅立叶变换，结果保存在自身</span></span><br><span class="line">	dft(complexIm, complexIm);</span><br><span class="line">	<span class="comment">// 将多通道的Mat矩阵分离成单通道的序列</span></span><br><span class="line">	split(complexIm, planes);</span><br><span class="line">	<span class="comment">//获取幅度图像，0通道为实数通道，1为虚数通道，因为二维傅立叶变换结果是复数</span></span><br><span class="line">	<span class="comment">// 计算二维矢量的幅值,第一个参数表示矢量的浮点型X坐标值,也就是实部;第二个参数表示矢量的浮点型Y坐标值,也就是虚部;第三个参数是输出的幅值</span></span><br><span class="line">	magnitude(planes[<span class="number">0</span>], planes[<span class="number">1</span>], planes[<span class="number">0</span>]);</span><br><span class="line">	Mat magI = planes[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">// 幅值都加上1再转换成对数尺度</span></span><br><span class="line">	magI += Scalar::all(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">log</span>(magI, magI);</span><br><span class="line">	<span class="comment">//重新排列傅里叶图像中的象限，使得原点位于图像中心</span></span><br><span class="line">	<span class="keyword">int</span> cx = padded.cols / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> cy = padded.rows / <span class="number">2</span>;</span><br><span class="line">	<span class="comment">// 根据中心点划定象限</span></span><br><span class="line">	<span class="function">Mat <span class="title">part1</span><span class="params">(planes[<span class="number">0</span>], Rect(<span class="number">0</span>, <span class="number">0</span>, cx, cy))</span></span>;</span><br><span class="line">	<span class="function">Mat <span class="title">part2</span><span class="params">(planes[<span class="number">0</span>], Rect(cx, <span class="number">0</span>, cx, cy))</span></span>;</span><br><span class="line">	<span class="function">Mat <span class="title">part3</span><span class="params">(planes[<span class="number">0</span>], Rect(<span class="number">0</span>, cy, cx, cy))</span></span>;</span><br><span class="line">	<span class="function">Mat <span class="title">part4</span><span class="params">(planes[<span class="number">0</span>], Rect(cx, cy, cx, cy))</span></span>;</span><br><span class="line">	Mat temp;</span><br><span class="line">	<span class="comment">//变换左上角和右下角象限,即交换p1和p4的幅值</span></span><br><span class="line">	part1.copyTo(temp);</span><br><span class="line">	part4.copyTo(part1);</span><br><span class="line">	temp.copyTo(part4);</span><br><span class="line">	<span class="comment">//变换右上角和左下角象限,即交换p2和p3的幅值</span></span><br><span class="line">	part2.copyTo(temp);</span><br><span class="line">	part3.copyTo(part2);</span><br><span class="line">	temp.copyTo(part3);</span><br><span class="line">	<span class="comment">// 最后频谱图应当归一化到0-1,然后显示频谱图</span></span><br><span class="line">	normalize(magI, magI, <span class="number">1</span>, <span class="number">0</span>, CV_MINMAX);</span><br><span class="line">	<span class="comment">//imshow("magnitude", magI);</span></span><br><span class="line">	<span class="comment">//waitKey(0);</span></span><br><span class="line">	<span class="comment">//destroyAllWindows();</span></span><br><span class="line">	normalize(magI, magI, <span class="number">0</span>, <span class="number">255</span>, CV_MINMAX);</span><br><span class="line">	imwrite(save_path_DFT_IDFT_1, magI);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 频谱图逆变换回原图</span></span><br><span class="line">	Mat _complexim;</span><br><span class="line">	<span class="comment">// 把complexIm的内容复制粘贴到_complexim</span></span><br><span class="line">	complexIm.copyTo(_complexim);</span><br><span class="line">	<span class="comment">//创建两个通道，类型为float，大小为填充后的尺寸,0通道为实数通道，1为虚数通道，因为二维傅立叶变换结果是复数</span></span><br><span class="line">	Mat iDft[] = &#123; Mat::zeros(planes[<span class="number">0</span>].size(),CV_32F),Mat::zeros(planes[<span class="number">0</span>].size(),CV_32F) &#125;;</span><br><span class="line">	<span class="comment">//傅立叶逆变换,求出原来数值</span></span><br><span class="line">	idft(_complexim, _complexim);</span><br><span class="line">	<span class="comment">// 分离成单通道序列</span></span><br><span class="line">	split(_complexim, iDft);</span><br><span class="line">	<span class="comment">// 我们主要使用0通道的值,即实部值就是我们原有的图像的像素值</span></span><br><span class="line">	magnitude(iDft[<span class="number">0</span>], iDft[<span class="number">1</span>], iDft[<span class="number">0</span>]);</span><br><span class="line">	normalize(iDft[<span class="number">0</span>], iDft[<span class="number">0</span>], <span class="number">0</span>, <span class="number">1</span>, CV_MINMAX);<span class="comment">//归一化处理，float类型的显示范围为0-1</span></span><br><span class="line">	<span class="comment">// 显示逆变换后图片</span></span><br><span class="line">	<span class="comment">//imshow("idft_picture", iDft[0]);</span></span><br><span class="line">	<span class="comment">//waitKey(0);</span></span><br><span class="line">	<span class="comment">//destroyAllWindows();</span></span><br><span class="line">	normalize(iDft[<span class="number">0</span>], iDft[<span class="number">0</span>], <span class="number">0</span>, <span class="number">255</span>, CV_MINMAX);</span><br><span class="line">	imwrite(save_path_DFT_IDFT_2, iDft[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Mat <span class="title">freqfilt</span><span class="params">(Mat &amp;scr, Mat &amp;blur)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//创建通道，存储dft后的实部与虚部（CV_32F，必须为单通道数）</span></span><br><span class="line">	Mat plane[] = &#123; scr, Mat::zeros(scr.size() , CV_32FC1) &#125;;</span><br><span class="line">	Mat complexIm;</span><br><span class="line">	<span class="comment">//合并通道(把两个矩阵合并为一个2通道的Mat类容器)</span></span><br><span class="line">	merge(plane, <span class="number">2</span>, complexIm);</span><br><span class="line">	<span class="comment">//进行傅立叶变换，结果保存在自身</span></span><br><span class="line">	dft(complexIm, complexIm);</span><br><span class="line">	<span class="comment">//分离通道(数组分离)</span></span><br><span class="line">	split(complexIm, plane);</span><br><span class="line">	plane[<span class="number">0</span>] = plane[<span class="number">0</span>](Rect(<span class="number">0</span>, <span class="number">0</span>, plane[<span class="number">0</span>].cols &amp; <span class="number">-2</span>, plane[<span class="number">0</span>].rows &amp; <span class="number">-2</span>));</span><br><span class="line">	<span class="keyword">int</span> cx = plane[<span class="number">0</span>].cols / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> cy = plane[<span class="number">0</span>].rows / <span class="number">2</span>;</span><br><span class="line">	<span class="function">Mat <span class="title">part1_r</span><span class="params">(plane[<span class="number">0</span>], Rect(<span class="number">0</span>, <span class="number">0</span>, cx, cy))</span></span>;</span><br><span class="line">	<span class="function">Mat <span class="title">part2_r</span><span class="params">(plane[<span class="number">0</span>], Rect(cx, <span class="number">0</span>, cx, cy))</span></span>;</span><br><span class="line">	<span class="function">Mat <span class="title">part3_r</span><span class="params">(plane[<span class="number">0</span>], Rect(<span class="number">0</span>, cy, cx, cy))</span></span>;</span><br><span class="line">	<span class="function">Mat <span class="title">part4_r</span><span class="params">(plane[<span class="number">0</span>], Rect(cx, cy, cx, cy))</span></span>;</span><br><span class="line">	Mat temp;</span><br><span class="line">	<span class="comment">//左上与右下交换位置(实部)</span></span><br><span class="line">	part1_r.copyTo(temp);</span><br><span class="line">	part4_r.copyTo(part1_r);</span><br><span class="line">	temp.copyTo(part4_r);</span><br><span class="line">	<span class="comment">//右上与左下交换位置(实部)</span></span><br><span class="line">	part2_r.copyTo(temp);</span><br><span class="line">	part3_r.copyTo(part2_r);</span><br><span class="line">	temp.copyTo(part3_r);</span><br><span class="line">	<span class="comment">//元素坐标(cx,cy)</span></span><br><span class="line">	<span class="function">Mat <span class="title">part1_i</span><span class="params">(plane[<span class="number">1</span>], Rect(<span class="number">0</span>, <span class="number">0</span>, cx, cy))</span></span>;</span><br><span class="line">	<span class="function">Mat <span class="title">part2_i</span><span class="params">(plane[<span class="number">1</span>], Rect(cx, <span class="number">0</span>, cx, cy))</span></span>;</span><br><span class="line">	<span class="function">Mat <span class="title">part3_i</span><span class="params">(plane[<span class="number">1</span>], Rect(<span class="number">0</span>, cy, cx, cy))</span></span>;</span><br><span class="line">	<span class="function">Mat <span class="title">part4_i</span><span class="params">(plane[<span class="number">1</span>], Rect(cx, cy, cx, cy))</span></span>;</span><br><span class="line">	<span class="comment">//左上与右下交换位置(虚部)</span></span><br><span class="line">	part1_i.copyTo(temp);</span><br><span class="line">	part4_i.copyTo(part1_i);</span><br><span class="line">	temp.copyTo(part4_i);</span><br><span class="line">	<span class="comment">//右上与左下交换位置(虚部)</span></span><br><span class="line">	part2_i.copyTo(temp);</span><br><span class="line">	part3_i.copyTo(part2_i);</span><br><span class="line">	temp.copyTo(part3_i);</span><br><span class="line">	<span class="comment">// 滤波器函数与DFT结果的乘积</span></span><br><span class="line">	Mat blur_r, blur_i, BLUR;</span><br><span class="line">	<span class="comment">//滤波(实部与滤波器模板对应元素相乘),plane[0]与blur逐个元素相乘</span></span><br><span class="line">	multiply(plane[<span class="number">0</span>], blur, blur_r);</span><br><span class="line">	<span class="comment">//滤波(虚部与滤波器模板对应元素相乘),plane[1]与blur逐个元素相乘</span></span><br><span class="line">	multiply(plane[<span class="number">1</span>], blur, blur_i);</span><br><span class="line">	Mat plane1[] = &#123; blur_r, blur_i &#125;;</span><br><span class="line">	<span class="comment">//实部与虚部合并</span></span><br><span class="line">	merge(plane1, <span class="number">2</span>, BLUR);</span><br><span class="line">	<span class="comment">//得到原图频谱图</span></span><br><span class="line">	<span class="comment">//获取幅度图像，0通道为实部通道，1为虚部，因为二维傅立叶变换结果是复数</span></span><br><span class="line">	magnitude(plane[<span class="number">0</span>], plane[<span class="number">1</span>], plane[<span class="number">0</span>]);</span><br><span class="line">	<span class="comment">//傅立叶变换后的图片不好分析，进行对数处理，结果比较好看</span></span><br><span class="line">	plane[<span class="number">0</span>] += Scalar::all(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">log</span>(plane[<span class="number">0</span>], plane[<span class="number">0</span>]);</span><br><span class="line">	<span class="comment">//归一化便于显示</span></span><br><span class="line">	normalize(plane[<span class="number">0</span>], plane[<span class="number">0</span>], <span class="number">0</span>, <span class="number">1</span>, CV_MINMAX);</span><br><span class="line">	<span class="comment">//imshow("原图像频谱图",plane[0]);</span></span><br><span class="line">	<span class="comment">//waitKey(0);</span></span><br><span class="line">	<span class="comment">//destroyAllWindows();</span></span><br><span class="line">	<span class="comment">//idft结果也为复数</span></span><br><span class="line">	idft(BLUR, BLUR);</span><br><span class="line">	<span class="comment">//分离通道，主要获取通道</span></span><br><span class="line">	split(BLUR, plane);</span><br><span class="line">	<span class="comment">//求幅值(模)</span></span><br><span class="line">	magnitude(plane[<span class="number">0</span>], plane[<span class="number">1</span>], plane[<span class="number">0</span>]);</span><br><span class="line">	<span class="comment">//归一化便于显示</span></span><br><span class="line">	normalize(plane[<span class="number">0</span>], plane[<span class="number">0</span>], <span class="number">0</span>, <span class="number">1</span>, CV_MINMAX);</span><br><span class="line">	<span class="comment">//返回参数</span></span><br><span class="line">	<span class="keyword">return</span> plane[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 理想低通滤波模板</span></span><br><span class="line"><span class="function">Mat <span class="title">ideal_low_pass_kernel</span><span class="params">(Mat &amp;scr, <span class="keyword">float</span> D0, <span class="built_in">string</span> save_path_ideal_low_pass_kernel)</span> </span>&#123;</span><br><span class="line">	<span class="function">Mat <span class="title">ideal_low_pass</span><span class="params">(scr.size(), CV_32FC1)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; scr.rows; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; scr.cols; j++) &#123;</span><br><span class="line">			<span class="keyword">double</span> d = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>((i - scr.rows / <span class="number">2</span>), <span class="number">2</span>) + <span class="built_in">pow</span>((j - scr.cols / <span class="number">2</span>), <span class="number">2</span>));</span><br><span class="line">			<span class="keyword">if</span> (d &lt;= D0) &#123;</span><br><span class="line">				ideal_low_pass.at&lt;<span class="keyword">float</span>&gt;(i, j) = <span class="number">1.0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				ideal_low_pass.at&lt;<span class="keyword">float</span>&gt;(i, j) = <span class="number">0.0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//imshow("ideal_low_pass_kernel", ideal_low_pass);</span></span><br><span class="line">	<span class="comment">//waitKey(0);</span></span><br><span class="line">	<span class="comment">//destroyAllWindows();</span></span><br><span class="line">	<span class="comment">// 归一化成255范围保存的图片和上面显示的效果一样</span></span><br><span class="line">	normalize(ideal_low_pass, ideal_low_pass, <span class="number">0</span>, <span class="number">255</span>, CV_MINMAX);</span><br><span class="line">	imwrite(save_path_ideal_low_pass_kernel, ideal_low_pass);</span><br><span class="line">	<span class="keyword">return</span> ideal_low_pass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 理想低通滤波,D0表示截止频率,D0是一个半径</span></span><br><span class="line"><span class="comment">// 半径D0越小,模糊越大;半径D0越大,模糊越小</span></span><br><span class="line"><span class="comment">// 中心点取频率矩形的中心,从点(u,v)到中心的距离为欧式距离D(u,v),如果距离小于等于D0,则H(u,v)=1,否则为0</span></span><br><span class="line"><span class="comment">// 振铃现象就是指输出图像的灰度剧烈变化处产生的震荡,就好像钟被敲击后产生的空气震荡</span></span><br><span class="line"><span class="comment">// 理想低通滤波器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ideal_low_pass_filter</span><span class="params">(<span class="built_in">string</span> load_path, <span class="keyword">float</span> d0, <span class="built_in">string</span> save_path_ideal_low_pass_kernel, <span class="built_in">string</span> save_path_ideal_low_pass_filter)</span> </span>&#123;</span><br><span class="line">	Mat pScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回,注意这里得到的pScr必须为灰度图格式,否则后面会报错,原因是如果读入RGB图像,padded也是三通道的RGB格式,那么Mat planes[]就会报错</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> row = pScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = pScr.cols;</span><br><span class="line">	<span class="keyword">int</span> channel = pScr.channels();</span><br><span class="line">	<span class="keyword">int</span> M = getOptimalDFTSize(pScr.rows);</span><br><span class="line">	<span class="keyword">int</span> N = getOptimalDFTSize(pScr.cols);</span><br><span class="line">	Mat padded;</span><br><span class="line">	copyMakeBorder(pScr, padded, <span class="number">0</span>, M - pScr.rows, <span class="number">0</span>, N - pScr.cols, BORDER_CONSTANT, Scalar::all(<span class="number">0</span>));</span><br><span class="line">	<span class="comment">//将图像转换为float型</span></span><br><span class="line">	padded.convertTo(padded, CV_32FC1);</span><br><span class="line">	Mat ideal_low_kernel = ideal_low_pass_kernel(padded, d0, save_path_ideal_low_pass_kernel);<span class="comment">//理想低通滤波器</span></span><br><span class="line">	Mat result = freqfilt(padded, ideal_low_kernel);</span><br><span class="line">	<span class="comment">//imshow("ideal_low_pass_kernel_picture", result);</span></span><br><span class="line">	<span class="comment">//waitKey(0);</span></span><br><span class="line">	<span class="comment">//destroyAllWindows();</span></span><br><span class="line">	normalize(result, result, <span class="number">0</span>, <span class="number">255</span>, CV_MINMAX);</span><br><span class="line">	imwrite(save_path_ideal_low_pass_filter, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 理想高通滤波模板</span></span><br><span class="line"><span class="function">Mat <span class="title">ideal_high_pass_kernel</span><span class="params">(Mat &amp;scr, <span class="keyword">float</span> D0, <span class="built_in">string</span> save_path_ideal_high_pass_kernel)</span> </span>&#123;</span><br><span class="line">	<span class="function">Mat <span class="title">ideal_high_pass</span><span class="params">(scr.size(), CV_32FC1)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; scr.rows; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; scr.cols; j++) &#123;</span><br><span class="line">			<span class="keyword">double</span> d = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>((i - scr.rows / <span class="number">2</span>), <span class="number">2</span>) + <span class="built_in">pow</span>((j - scr.cols / <span class="number">2</span>), <span class="number">2</span>));</span><br><span class="line">			<span class="keyword">if</span> (d &lt;= D0) &#123;</span><br><span class="line">				ideal_high_pass.at&lt;<span class="keyword">float</span>&gt;(i, j) = <span class="number">0.0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				ideal_high_pass.at&lt;<span class="keyword">float</span>&gt;(i, j) = <span class="number">1.0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//imshow("ideal_high_pass_kernel", ideal_high_pass);</span></span><br><span class="line">	<span class="comment">//waitKey(0);</span></span><br><span class="line">	<span class="comment">//destroyAllWindows();</span></span><br><span class="line">	<span class="comment">// 归一化成255范围保存的图片和上面显示的效果一样</span></span><br><span class="line">	normalize(ideal_high_pass, ideal_high_pass, <span class="number">0</span>, <span class="number">255</span>, CV_MINMAX);</span><br><span class="line">	imwrite(save_path_ideal_high_pass_kernel, ideal_high_pass);</span><br><span class="line">	<span class="keyword">return</span> ideal_high_pass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 理想高通滤波,和理想低通滤波正好相反,中心点取频率矩形的中心,从点(u,v)到中心的距离为欧式距离D(u,v),如果距离小于等于D0,则H(u,v)=0,否则为1</span></span><br><span class="line"><span class="comment">// 高通滤波后图像得到锐化处理,图像中仅剩下边缘</span></span><br><span class="line"><span class="comment">// 理想高通滤波器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ideal_high_pass_filter</span><span class="params">(<span class="built_in">string</span> load_path, <span class="keyword">float</span> d0, <span class="built_in">string</span> save_path_ideal_high_pass_kernel, <span class="built_in">string</span> save_path_ideal_high_pass_filter)</span> </span>&#123;</span><br><span class="line">	Mat pScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回,注意这里得到的pScr必须为灰度图格式,否则后面会报错,原因是如果读入RGB图像,padded也是三通道的RGB格式,那么Mat planes[]就会报错</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> row = pScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = pScr.cols;</span><br><span class="line">	<span class="keyword">int</span> channel = pScr.channels();</span><br><span class="line">	<span class="keyword">int</span> M = getOptimalDFTSize(pScr.rows);</span><br><span class="line">	<span class="keyword">int</span> N = getOptimalDFTSize(pScr.cols);</span><br><span class="line">	Mat padded;</span><br><span class="line">	copyMakeBorder(pScr, padded, <span class="number">0</span>, M - pScr.rows, <span class="number">0</span>, N - pScr.cols, BORDER_CONSTANT, Scalar::all(<span class="number">0</span>));</span><br><span class="line">	<span class="comment">//将图像转换为float型</span></span><br><span class="line">	padded.convertTo(padded, CV_32FC1);</span><br><span class="line">	Mat ideal_high_kernel = ideal_high_pass_kernel(padded, d0, save_path_ideal_high_pass_kernel);<span class="comment">//理想低通滤波器</span></span><br><span class="line">	Mat result = freqfilt(padded, ideal_high_kernel);</span><br><span class="line">	<span class="comment">//imshow("ideal_high_pass_kernel_picture", result);</span></span><br><span class="line">	<span class="comment">//waitKey(0);</span></span><br><span class="line">	<span class="comment">//destroyAllWindows();</span></span><br><span class="line">	normalize(result, result, <span class="number">0</span>, <span class="number">255</span>, CV_MINMAX);</span><br><span class="line">	imwrite(save_path_ideal_high_pass_filter, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 巴特沃斯低通滤波模板</span></span><br><span class="line"><span class="comment">// 阶数n=1 无振铃和负值</span></span><br><span class="line"><span class="comment">// 阶数n=2 轻微振铃和负值</span></span><br><span class="line"><span class="comment">// 阶数n=5 明显振铃和负值</span></span><br><span class="line"><span class="comment">// 半径D0越小,模糊越大;半径D0越大,模糊越小</span></span><br><span class="line"><span class="function">Mat <span class="title">butterworth_low_pass_kernel</span><span class="params">(Mat &amp;scr, <span class="keyword">float</span> D0, <span class="keyword">int</span> n, <span class="built_in">string</span> save_path_butterworth_low_pass_kernel)</span> </span>&#123;</span><br><span class="line">	<span class="function">Mat <span class="title">butterworth_low_pass</span><span class="params">(scr.size(), CV_32FC1)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; scr.rows; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; scr.cols; j++) &#123;</span><br><span class="line">			<span class="comment">//计算pow必须为float型</span></span><br><span class="line">			<span class="keyword">double</span> d = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>((i - scr.rows / <span class="number">2</span>), <span class="number">2</span>) + <span class="built_in">pow</span>((j - scr.cols / <span class="number">2</span>), <span class="number">2</span>));</span><br><span class="line">			butterworth_low_pass.at&lt;<span class="keyword">float</span>&gt;(i, j) = <span class="number">1.0</span> / (<span class="number">1</span> + <span class="built_in">pow</span>(d / D0, <span class="number">2</span> * n));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//imshow("butterworth_low_path_kernel", butterworth_low_pass);</span></span><br><span class="line">	<span class="comment">//waitKey(0);</span></span><br><span class="line">	<span class="comment">//destroyAllWindows();</span></span><br><span class="line">	<span class="comment">// 归一化成255范围保存的图片和上面显示的效果一样</span></span><br><span class="line">	normalize(butterworth_low_pass, butterworth_low_pass, <span class="number">0</span>, <span class="number">255</span>, CV_MINMAX);</span><br><span class="line">	imwrite(save_path_butterworth_low_pass_kernel, butterworth_low_pass);</span><br><span class="line">	<span class="keyword">return</span> butterworth_low_pass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 巴特沃斯低通滤波器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">butterworth_low_pass_filter</span><span class="params">(<span class="built_in">string</span> load_path, <span class="keyword">float</span> d0, <span class="keyword">int</span> n, <span class="built_in">string</span> save_path_butterworth_low_pass_kernel, <span class="built_in">string</span> save_path_butterworth_low_pass_filter)</span> </span>&#123;</span><br><span class="line">	Mat pScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回,注意这里得到的pScr必须为灰度图格式,否则后面会报错,原因是如果读入RGB图像,padded也是三通道的RGB格式,那么Mat planes[]就会报错</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> row = pScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = pScr.cols;</span><br><span class="line">	<span class="keyword">int</span> channel = pScr.channels();</span><br><span class="line">	<span class="keyword">int</span> M = getOptimalDFTSize(pScr.rows);</span><br><span class="line">	<span class="keyword">int</span> N = getOptimalDFTSize(pScr.cols);</span><br><span class="line">	Mat padded;</span><br><span class="line">	copyMakeBorder(pScr, padded, <span class="number">0</span>, M - pScr.rows, <span class="number">0</span>, N - pScr.cols, BORDER_CONSTANT, Scalar::all(<span class="number">0</span>));</span><br><span class="line">	<span class="comment">//将图像转换为float型</span></span><br><span class="line">	padded.convertTo(padded, CV_32FC1);</span><br><span class="line">	Mat butterworth_kernel = butterworth_low_pass_kernel(padded, d0, n, save_path_butterworth_low_pass_kernel);<span class="comment">//理想低通滤波器</span></span><br><span class="line">	Mat result = freqfilt(padded, butterworth_kernel);</span><br><span class="line">	<span class="comment">//imshow("butterworth_low_pass_filter_picture", result);</span></span><br><span class="line">	<span class="comment">//waitKey(0);</span></span><br><span class="line">	<span class="comment">//destroyAllWindows();</span></span><br><span class="line">	normalize(result, result, <span class="number">0</span>, <span class="number">255</span>, CV_MINMAX);</span><br><span class="line">	imwrite(save_path_butterworth_low_pass_filter, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 巴特沃斯高通滤波模板</span></span><br><span class="line"><span class="function">Mat <span class="title">butterworth_high_pass_kernel</span><span class="params">(Mat &amp;scr, <span class="keyword">float</span> D0, <span class="keyword">int</span> n, <span class="built_in">string</span> save_path_butterworth_high_pass_kernel)</span> </span>&#123;</span><br><span class="line">	<span class="function">Mat <span class="title">butterworth_high_pass</span><span class="params">(scr.size(), CV_32FC1)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; scr.rows; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; scr.cols; j++) &#123;</span><br><span class="line">			<span class="comment">//计算pow必须为float型</span></span><br><span class="line">			<span class="keyword">double</span> d = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>((i - scr.rows / <span class="number">2</span>), <span class="number">2</span>) + <span class="built_in">pow</span>((j - scr.cols / <span class="number">2</span>), <span class="number">2</span>));</span><br><span class="line">			butterworth_high_pass.at&lt;<span class="keyword">float</span>&gt;(i, j) = <span class="number">1.0</span> / (<span class="number">1</span> + <span class="built_in">pow</span>(D0 / d, <span class="number">2</span> * n));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//imshow("butterworth_high_path_kernel", butterworth_high_pass);</span></span><br><span class="line">	<span class="comment">//waitKey(0);</span></span><br><span class="line">	<span class="comment">//destroyAllWindows();</span></span><br><span class="line">	<span class="comment">// 归一化成255范围保存的图片和上面显示的效果一样</span></span><br><span class="line">	normalize(butterworth_high_pass, butterworth_high_pass, <span class="number">0</span>, <span class="number">255</span>, CV_MINMAX);</span><br><span class="line">	imwrite(save_path_butterworth_high_pass_kernel, butterworth_high_pass);</span><br><span class="line">	<span class="keyword">return</span> butterworth_high_pass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 巴特沃斯高通滤波器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">butterworth_high_pass_filter</span><span class="params">(<span class="built_in">string</span> load_path, <span class="keyword">float</span> d0, <span class="keyword">int</span> n, <span class="built_in">string</span> save_path_butterworth_high_pass_kernel, <span class="built_in">string</span> save_path_butterworth_high_pass_filter)</span> </span>&#123;</span><br><span class="line">	Mat pScr;</span><br><span class="line">	<span class="comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回,注意这里得到的pScr必须为灰度图格式,否则后面会报错,原因是如果读入RGB图像,padded也是三通道的RGB格式,那么Mat planes[]就会报错</span></span><br><span class="line">	pScr = imread(load_path, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> row = pScr.rows;</span><br><span class="line">	<span class="keyword">int</span> col = pScr.cols;</span><br><span class="line">	<span class="keyword">int</span> channel = pScr.channels();</span><br><span class="line">	<span class="keyword">int</span> M = getOptimalDFTSize(pScr.rows);</span><br><span class="line">	<span class="keyword">int</span> N = getOptimalDFTSize(pScr.cols);</span><br><span class="line">	Mat padded;</span><br><span class="line">	copyMakeBorder(pScr, padded, <span class="number">0</span>, M - pScr.rows, <span class="number">0</span>, N - pScr.cols, BORDER_CONSTANT, Scalar::all(<span class="number">0</span>));</span><br><span class="line">	<span class="comment">//将图像转换为float型</span></span><br><span class="line">	padded.convertTo(padded, CV_32FC1);</span><br><span class="line">	Mat butterworth_kernel = butterworth_high_pass_kernel(padded, d0, n, save_path_butterworth_high_pass_kernel);<span class="comment">//理想低通滤波器</span></span><br><span class="line">	Mat result = freqfilt(padded, butterworth_kernel);</span><br><span class="line">	<span class="comment">//imshow("butterworth_high_pass_filter_picture", result);</span></span><br><span class="line">	<span class="comment">//waitKey(0);</span></span><br><span class="line">	<span class="comment">//destroyAllWindows();</span></span><br><span class="line">	normalize(result, result, <span class="number">0</span>, <span class="number">255</span>, CV_MINMAX);</span><br><span class="line">	imwrite(save_path_butterworth_high_pass_filter, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> load_path = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/5/save/lenna.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_gray_image = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/5/save/lenna_gray.bmp"</span>;</span><br><span class="line">	gray_image(load_path, save_path_gray_image);</span><br><span class="line">	<span class="built_in">string</span> load_gray_path = save_path_gray_image;</span><br><span class="line">	<span class="built_in">string</span> save_path_DFT_gray = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/5/save/lenna_DFT_gray.bmp"</span>;</span><br><span class="line">	DFT(load_gray_path, save_path_DFT_gray);</span><br><span class="line">	<span class="built_in">string</span> save_path_DFT_IDFT_gray_1 = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/5/save/lenna_DFT_IDFT_gray_1 .bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_DFT_IDFT_gray_2 = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/5/save/lenna_DFT_IDFT_gray_2 .bmp"</span>;</span><br><span class="line">	DFT_IDFT(load_gray_path, save_path_DFT_IDFT_gray_1, save_path_DFT_IDFT_gray_2);</span><br><span class="line">	<span class="built_in">string</span> save_path_ideal_low_pass_kernel = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/5/save/lenna_ideal_low_pass_kernel .bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_ideal_low_pass_filter_gray = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/5/save/lenna_ideal_low_pass_filter_gray .bmp"</span>;</span><br><span class="line">	ideal_low_pass_filter(load_gray_path, <span class="number">60.0</span>, save_path_ideal_low_pass_kernel, save_path_ideal_low_pass_filter_gray);</span><br><span class="line">	<span class="built_in">string</span> save_path_ideal_high_pass_kernel = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/5/save/lenna_ideal_high_pass_kernel.bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_ideal_high_pass_filter_gray = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/5/save/lenna_ideal_high_pass_filter_gray .bmp"</span>;</span><br><span class="line">	ideal_high_pass_filter(load_gray_path, <span class="number">30.0</span>, save_path_ideal_high_pass_kernel, save_path_ideal_high_pass_filter_gray);</span><br><span class="line">	<span class="built_in">string</span> save_path_butterworth_low_path_kernel = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/5/save/lenna_butterworth_low_path_kernel_gray .bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_butterworth_low_pass_filter_gray = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/5/save/lenna_butterworth_low_pass_filter_gray .bmp"</span>;</span><br><span class="line">	butterworth_low_pass_filter(load_gray_path, <span class="number">60.0</span>, <span class="number">2</span>, save_path_butterworth_low_path_kernel,save_path_butterworth_low_pass_filter_gray);</span><br><span class="line">	<span class="built_in">string</span> save_path_butterworth_high_path_kernel = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/5/save/lenna_butterworth_high_path_kernel_gray .bmp"</span>;</span><br><span class="line">	<span class="built_in">string</span> save_path_butterworth_high_pass_filter_gray = <span class="string">"C:/Users/zgcr6/Desktop/高图实验/5/save/lenna_butterworth_high_pass_filter_gray .bmp"</span>;</span><br><span class="line">	butterworth_high_pass_filter(load_gray_path, <span class="number">60.0</span>, <span class="number">2</span>, save_path_butterworth_high_path_kernel, save_path_butterworth_high_pass_filter_gray);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


            </div>
            <hr/>

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff;
        background-color: #22AB38;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff;
        background-color: #019FE8;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a class="reward-link btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs">
                        <li class="tab wechat-tab waves-effect waves-light"><a class="active" href="#wechat">微信</a></li>
                        <li class="tab alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                    </ul>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('#reward .reward-link').on('click', function () {
            $('#rewardModal').openModal();
        });

        $('#rewardModal .close').on('click', function () {
            $('#rewardModal').closeModal();
        });
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            <div class="reprint">
                <p>
                    <span class="reprint-tip">
                        <i class="fa fa-exclamation-circle"></i>&nbsp;&nbsp;Reprint please specify:
                    </span>
                    <a href="https://wyg1996.cn" class="b-link-green">鱼缸屋</a>
                    <i class="fa fa-angle-right fa-lg fa-fw text-color"></i>
                    <a href="/2019/05/04/高级图像处理基础实验与图像处理基础理论知识/" class="b-link-green">高级图像处理基础实验与图像处理基础理论知识</a>
                </p>
            </div>
        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: '',
        owner: '',
        admin: null,
        id: '2019-05-04T16-00-32',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    
        <link rel="stylesheet" href="/libs/gitment/gitment-default.css">
<link rel="stylesheet" href="/css/gitment.css">

<div class="gitment-card card" data-aos="fade-up">
    <div id="gitment-content" class="card-content"></div>
</div>

<script src="/libs/gitment/gitment.js"></script>
<script>
var gitment = new Gitment({
    id: 'Sat May 04 2019 16:00:32 GMT+0800',
    owner: '',
    repo: '',
    oauth: {
        client_id: '',
        client_secret: ''
    }
});

gitment.render('gitment-content');
</script>
    

    
        <div class="disqus-card card" data-aos="fade-up">
    <div id="disqus_thread" class="card-content">
        <noscript>Please enable JavaScript to view the
            <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
    </div>
</div>

<script type="text/javascript">
    disqus_config = function () {
        this.page.url = 'https://wyg1996.cn/2019/05/04/高级图像处理基础实验与图像处理基础理论知识/';
        this.page.identifier = '/2019/05/04/高级图像处理基础实验与图像处理基础理论知识/';
        this.page.title = '高级图像处理基础实验与图像处理基础理论知识';
    };
    let disqus_shortname = '';

    (function () { // DON'T EDIT BELOW THIS LINE
        let d = document, s = d.createElement('script');
        // 如：s.src = 'https://blinkfox.disqus.com/embed.js';
        s.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
    

    
    <div class="livere-card card" data-aos="fade-up">
    <!-- 来必力City版安装代码 -->
    <div id="lv-container" class="card-content" data-id="city" data-uid="">
        <script type="text/javascript">
            (function (d, s) {
                let j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') {
                    return;
                }

                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript。</noscript>
    </div>
    <!-- City版安装代码已完成 -->
</div>
    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2019/05/04/高级图像处理扩展实验/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/20.jpg" class="responsive-img" alt="高级图像处理扩展实验">
                        
                        <span class="card-title">高级图像处理扩展实验</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">实验一：对视频进行物体边缘检测（Laplacian/canny）实验一内容读取摄像头或视频，对每一帧的图片使用拉普拉斯算子进行或canny算子进行物体边缘检测。拉普拉斯算子我们在前一篇文章中已经介绍过，现在介绍一下canny算子。
cann</div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2019-05-04
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/图像处理/" class="post-category" target="_blank">
                                    图像处理
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/图像处理/" target="_blank">
                        <span class="chip bg-color">图像处理</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/05/03/CTR预估算法FM、FFM、deepFM原理/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/3.jpg" class="responsive-img" alt="CTR预估算法FM、FFM、deepFM原理">
                        
                        <span class="card-title">CTR预估算法FM、FFM、deepFM原理</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">FM/FFM算法的产生我们使用传统的线性模型（如逻辑回归）进行广告CTR（广告点击率）、CVR（转化率）预测时，往往遇到下面的问题:

数据集特征极度稀疏。许多特征如用户的地区、职业等都是类别型特征，其特征取值非常多，但每个取值的出现次数很</div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2019-05-03
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/推荐系统/" class="post-category" target="_blank">
                                    推荐系统
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/推荐系统/" target="_blank">
                        <span class="chip bg-color">推荐系统</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + 'From: 鱼缸屋<br />'
            + 'Author: ygwu<br />'
            + 'Link: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>

    </div>
    <div class="col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });
    });
</script>
    

</main>


<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            &copy;<a href="mailto:ygwu@mail.ustc.edu.cn" target="_blank">鱼缸屋</a>
            

            
                &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
                <span class="white-color">393.6k</span>
            

            
			
                <br>
                
                <span id="busuanzi_container_site_pv">
                    <i class="fa fa-heart-o"></i>
                    本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
                </span>
                
                
                <span id="busuanzi_container_site_uv">
                    <i class="fa fa-users"></i>
                    次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
                </span>
                
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/wygny" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:ygwu@mail.ustc.edu.cn" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=321699849" class="tooltipped" data-tooltip="QQ联系我: 321699849" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>



    <a href="https://www.baidu.com" class="tooltipped" target="_blank" data-tooltip="访问百度" data-position="top" data-delay="50">
        <i class="fa fa-paw"></i>
</a>



    <a href="https://www.google.com" class="tooltipped" target="_blank" data-tooltip="访问谷歌" data-position="top" data-delay="50">
        <i class="fa fa-google"></i>
</a>



    <a href="https://www.bilibili.com" class="tooltipped" target="_blank" data-tooltip="访问哔哩哔哩" data-position="top" data-delay="50">
        <i class="fa fa-bullseye"></i>
</a>



    <a href="https://blog.csdn.net/zgcr654321" class="tooltipped" target="_blank" data-tooltip="访问我的CSDN博客" data-position="top" data-delay="50">
        <i class="fa fa-copyright"></i>
</a>






</div>
    </div>
</footer>

<div class="progress-bar"></div>


<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input" autofocus="">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


<script src="/libs/materialize/js/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->



    <script src="/libs/others/clicklove.js"></script>


    <script async src="/libs/others/busuanzi.pure.mini.js"></script>


</body>
</html>